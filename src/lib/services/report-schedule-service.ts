import { ObjectId } from 'mongodb';
import cronParser from 'cron-parser';
import { getReportSchedulesCollection } from '@/lib/db-tenant';
import { ReportSchedule, CreateReportScheduleSchema, UpdateReportScheduleSchema } from '@/lib/schemas/report-schedule';
import { AppError } from '@/lib/errors';
import { logEvento } from '@/lib/logger';
import { ReportTemplateRegistry } from '@/lib/report-templates/registry';
import { generateTemplatedReport } from '@/lib/server-pdf-utils';
import { sendReportDelivery } from '@/lib/email-service';
import { ReportData } from '@/lib/schemas/report-template';

export class ReportScheduleService {

    /**
     * Creates a new report schedule.
     */
    static async createSchedule(session: any, data: any): Promise<string> {
        const validated = CreateReportScheduleSchema.parse(data);

        // Validate cron expression
        try {
            (cronParser as any).parseExpression(validated.cronExpression);
        } catch (err) {
            throw new AppError('VALIDATION_ERROR', 400, 'Invalid cron expression');
        }

        const collection = await getReportSchedulesCollection(session);

        // Calculate next run
        const interval = (cronParser as any).parseExpression(validated.cronExpression);
        const nextRunAt = interval.next().toDate();

        const schedule: ReportSchedule = {
            ...validated,
            tenantId: session.user.tenantId,
            createdBy: session.user.id,
            nextRunAt,
            createdAt: new Date(),
            updatedAt: new Date(),
            enabled: true
        };

        const result: any = await collection.insertOne(schedule);

        await logEvento({
            level: 'INFO',
            source: 'API_ADMIN',
            action: 'CREATE',
            message: `Schedule created: ${validated.name}`,
            tenantId: session.user.tenantId,
            correlationId: `create-sched-${Date.now()}`,
            details: { scheduleId: result.insertedId.toString() }
        } as any);

        return result.insertedId.toString();
    }

    /**
     * Lists schedules for the current tenant.
     */
    static async listSchedules(session: any): Promise<ReportSchedule[]> {
        const collection = await getReportSchedulesCollection(session);
        // SecureCollection.find returns Promise<T[]> directly
        return collection.find({});
    }

    /**
     * Gets due schedules for execution.
     * WARNING: This runs in a system context (cron), so we bypass tenant filtering for retrieval,
     * but we must respect tenant isolation during execution.
     */
    static async getDueSchedules(): Promise<ReportSchedule[]> {
        // Direct DB access for system-level cron job
        const { getMongoClient } = await import('@/lib/db');
        const client = await getMongoClient();
        const db = client.db();
        const collection = db.collection<ReportSchedule>('report_schedules'); // Raw collection

        const now = new Date();
        return collection.find({
            enabled: true,
            nextRunAt: { $lte: now }
        }).toArray();
    }

    /**
     * Executes a single schedule.
     */
    static async executeSchedule(schedule: ReportSchedule): Promise<void> {
        // Safe check for _id existence
        if (!schedule._id) return;

        const correlationId = `exec-sched-${schedule._id}-${Date.now()}`;

        try {
            await logEvento({
                level: 'INFO',
                source: 'REPORT_SCHEDULER',
                action: 'EXECUTE_INIT',
                message: `Executing schedule: ${schedule.name}`,
                tenantId: schedule.tenantId,
                correlationId
            });

            const template = ReportTemplateRegistry.getTemplateByType(schedule.templateType);
            if (!template) {
                throw new Error(`Template type ${schedule.templateType} not found`);
            }

            // Mock Data Generation (similar to API behavior)
            // In a real scenario, we would use schedule.dataFilters to query actual data
            const reportData: ReportData = {
                title: template.name,
                subtitle: `Scheduled Report - ${schedule.name}`,
                tenantId: schedule.tenantId,
                date: new Date(),
                technician: 'System Automation',
                branding: {},
                data: schedule.dataFilters || {
                    metrics: [],
                    equipment: [],
                    findings: [],
                    riskText: 'Automated generation.',
                    recommendations: 'Generated by ReportScheduleService.'
                }
            };

            const pdfBuffer = await generateTemplatedReport(template, reportData, {
                locale: schedule.locale
            });

            // Send Emails
            const results = await Promise.allSettled(schedule.recipients.map(recipient =>
                sendReportDelivery({
                    to: recipient,
                    reportName: schedule.name,
                    templateType: template.name,
                    generatedAt: new Date(),
                    pdfBuffer,
                    fileName: `${template.type}-${new Date().toISOString().split('T')[0]}.pdf`
                })
            ));

            const failed = results.filter(r => r.status === 'rejected').length;

            // Update Schedule (nextRunAt)
            const interval = (cronParser as any).parseExpression(schedule.cronExpression);
            const nextRunAt = interval.next().toDate();

            // Update via raw collection to avoid session requirement here if running in background
            const { getMongoClient } = await import('@/lib/db');
            const client = await getMongoClient();
            const db = client.db();
            const collection = db.collection('report_schedules');

            await collection.updateOne(
                { _id: new ObjectId(schedule._id) },
                {
                    $set: {
                        lastRunAt: new Date(),
                        nextRunAt,
                        updatedAt: new Date()
                    }
                }
            );

            await logEvento({
                level: failed > 0 ? 'WARN' : 'INFO',
                source: 'REPORT_SCHEDULER',
                action: 'EXECUTE_COMPLETE',
                message: `Schedule executed. Emails: ${schedule.recipients.length - failed}/${schedule.recipients.length} sent.`,
                tenantId: schedule.tenantId,
                correlationId,
                details: { nextRunAt }
            });

        } catch (error: any) {
            console.error(`Failed to execute schedule ${schedule._id}:`, error);
            await logEvento({
                level: 'ERROR',
                source: 'REPORT_SCHEDULER',
                action: 'EXECUTE_FAILED',
                message: error.message || 'Unknown error',
                tenantId: schedule.tenantId,
                correlationId,
                details: { stack: error.stack }
            });
        }
    }
}
