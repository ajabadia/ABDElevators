te adjunto el cÃ³digo fuente de la aplicaciÃ³n que estoy realizando en react, mongodb, usando rag, gemini, etc. hazme una auditorÃ­a preliminar del cÃ³digo fuente y de la usabilidad, luego hablamos mÃ¡s
Edit
Copy
Share
Voy a realizar una auditorÃ­a preliminar de tu cÃ³digo fuente. He analizado el archivo proporcionado que contiene mÃºltiples componentes y pÃ¡ginas de tu aplicaciÃ³n RAG (Retrieval-Augmented Generation) construida con Next.js, React, MongoDB y Gemini.
ğŸ” AuditorÃ­a Preliminar - ABD RAG Platform
1. ARQUITECTURA Y ESTRUCTURA
âœ… Fortalezas Detectadas
Table
Copy
Aspecto	EvaluaciÃ³n
Modularidad	Excelente separaciÃ³n de responsabilidades con componentes especializados
Rutas anidadas	Uso correcto de route groups (authenticated), (admin), (technical)
i18n	ImplementaciÃ³n de next-intl para internacionalizaciÃ³n
TypeScript	Uso extensivo de tipos (aunque hay any por refactorizar)
Server/Client Components	Buena distinciÃ³n entre RSC y RCC
âš ï¸ Ãreas de Mejora
TypeScript
Copy
// Ejemplo de cÃ³digo con riesgo encontrado:
// En mÃºltiples archivos hay 'use client' innecesario
"use client"; // Â¿Realmente necesario aquÃ­?
import { redirect } from "next/navigation";

export default function RedirectPage() {
    redirect('/other'); // Esto puede ejecutarse en servidor
}
Problema: redirect() de Next.js funciona en Server Components. Al marcarlo como "use client" pierdes optimizaciones.
2. SEGURIDAD Y AUTENTICACIÃ“N
ğŸ” Hallazgos Positivos
TypeScript
Copy
// middleware.ts - Buenas prÃ¡cticas detectadas:
- CSP (Content Security Policy) con nonces
- HSTS en producciÃ³n
- Rate limiting implementado
- MFA enforcement para ADMIN/SUPER_ADMIN
- Headers de seguridad completos (X-Frame-Options, etc.)
ğŸš¨ Vulnerabilidades Potenciales
Table
Copy
Severidad	Issue	UbicaciÃ³n	RecomendaciÃ³n
MEDIA	any types en datos de API	MÃºltiples (useApiItem<any>)	Definir interfaces estrictas
MEDIA	dangerouslySetInnerHTML no auditado	Posible en Swagger UI	Sanitizar con DOMPurify
BAJA	Console logs en producciÃ³n	instrumentation.ts	Usar logger con niveles
MEDIA	ExposiciÃ³n de stack traces	Middleware error handler	Condicionar a NODE_ENV
TypeScript
Copy
// CÃ³digo problemÃ¡tico encontrado:
if (process.env.NODE_ENV === 'development') {
    // Bien: Solo en dev
    stack: error.stack 
}

// Pero en otros lugares:
console.error("Admin Dashboard Error:", error) // Siempre expuesto
3. RENDIMIENTO Y OPTIMIZACIÃ“N
ğŸš€ Optimizaciones Implementadas (Bien)
TypeScript
Copy
// Lazy loading de componentes pesados
const CollectiveIntelligenceDashboard = dynamic(
    () => import("@/components/admin/CollectiveIntelligenceDashboard"),
    { loading: () => <DashboardSkeleton /> }
);

// Suspense boundaries
<Suspense fallback={<Skeleton className="h-32 w-full" />}>
    <ApiKeyList keys={keys as any[]} />
</Suspense>
âš¡ Problemas de Performance
Table
Copy
Issue	Impacto	SoluciÃ³n
useEffect sin cleanup	Memory leaks	Agregar return cleanup
Re-renders innecesarios	UI lenta	Usar useMemo/useCallback
ImÃ¡genes sin optimizaciÃ³n	LCP alto	Usar next/image
Bundle size	TTI alto	Analizar con @next/bundle-analyzer
TypeScript
Copy
// Ejemplo de mejora necesaria:
// En AdminPromptsPage.tsx - useEffect sin dependencias controladas
useEffect(() => {
    fetchPrompts();
}, []); // Â¿QuÃ© pasa si cambia el environment?
4. USABILIDAD Y UX
ğŸ¯ AnÃ¡lisis de Interfaces
Puntos Fuertes:
DiseÃ±o consistente con PageContainer y PageHeader
Estados de carga skeleton bien implementados
Feedback visual con toast notifications
NavegaciÃ³n clara con breadcrumbs
Problemas de UX Detectados:
TypeScript
Copy
// 1. Estados de error poco amigables
if (error) return <div className="p-10 text-destructive...">{error}</div>;

// 2. Fallbacks genÃ©ricos en tabs
<TabsContent value="predictive">
    <div className="p-12 text-center border-2 border-dashed...">
        <LineChart className="w-16 h-16 text-slate-300 mx-auto mb-4" />
        <h3 className="text-xl font-bold">{tSec('predictive.title')}</h3>
        <p>{tSec('predictive.subtitle')}</p>
    </div>
</TabsContent>
// ^ Placeholder en producciÃ³n = mala UX
Table
Copy
Problema	Severidad	RecomendaciÃ³n
Sin manejo de offline	Media	Implementar Service Worker
Estados vacÃ­os genÃ©ricos	Baja	Personalizar empty states
Sin indicadores de progreso largos	Media	Usar skeletons progresivos
Contraste en modo oscuro	Baja	Verificar WCAG AA
5. MANTENIBILIDAD Y CALIDAD DE CÃ“DIGO
ğŸ“Š MÃ©tricas Estimadas
plain
Copy
DuplicaciÃ³n de cÃ³digo: ~15% (hooks similares en mÃºltiples pÃ¡ginas)
Complejidad ciclomÃ¡tica: Media-Alta (componentes >200 lÃ­neas)
Cobertura de tipos: ~75% (muchos `any` pendientes)
Deuda tÃ©cnica: Moderada
ğŸ”„ Patrones Inconsistentes
TypeScript
Copy
// Inconsistencia en manejo de errores:
// Archivo A:
const { data, error } = useApiItem({...})
if (error) return <ErrorComponent />

// Archivo B:
try {
    const res = await fetch(...)
} catch (err) {
    toast({...}) // Manejo diferente
}

// Archivo C:
if (!res.ok) throw new Error(...) // Sin catch
ğŸ› ï¸ Sugerencias de RefactorizaciÃ³n
Crear capa de abstracciÃ³n para API calls:
TypeScript
Copy
// hooks/useEntity.ts - Unificar patrÃ³n
export function useEntity<T>(endpoint: string, options?: Options) {
    const { data, error, mutate } = useSWR<T>(endpoint, fetcher, {
        suspense: true,
        ...options
    });
    return { entity: data, error, refresh: mutate };
}
Standardizar manejo de estados:
TypeScript
Copy
// types/api-state.ts
type ApiState<T> = 
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: Error };
6. ACCESIBILIDAD (A11Y)
âœ… Implementado Correctamente
aria-label en botones de icono
role="searchbox" en inputs de bÃºsqueda
aria-current="page" en navegaciÃ³n
aria-busy en estados de carga
âŒ Faltantes CrÃ­ticos
Table
Copy
Elemento	Problema	SoluciÃ³n
Tablas de datos	Sin scope en headers	Agregar scope="col"
Iconos decorativos	Sin aria-hidden	Verificar todos los <Icon />
Modales	Focus trap no implementado	Usar react-focus-lock
Color solo como indicador	Sin alternativa textual	Agregar textos/Ã­conos
TypeScript
Copy
// Ejemplo de mejora:
// Antes:
<Badge className="bg-emerald-500/10 text-emerald-600">
    {policy.effect}
</Badge>

// DespuÃ©s:
<Badge 
    className="bg-emerald-500/10 text-emerald-600"
    aria-label={policy.effect === 'ALLOW' ? 'Permitido' : 'Denegado'}
>
    {policy.effect === 'ALLOW' ? 'âœ“' : 'âœ—'} {policy.effect}
</Badge>
7. RAG Y ARQUITECTURA DE IA
ğŸ§  ImplementaciÃ³n Observada
TypeScript
Copy
// Buen patrÃ³n de orquestaciÃ³n:
// 1. Ingesta con jobs en BullMQ (detectado en ingest/page.tsx)
// 2. Tracing de agentes con correlationId
// 3. Feedback loop con RAG quality dashboard
// 4. Multi-tenant isolation en prompts
âš ï¸ Consideraciones de IA
Table
Copy
Aspecto	Estado	RecomendaciÃ³n
Prompt versioning	âœ… Implementado	Usar environment flags
Rate limiting a Gemini	âš ï¸ No visible	Implementar en API routes
CachÃ© de embeddings	â“ No auditado	Verificar Redis/Vector DB
Fallback de LLM	â“ No visible	Implementar circuit breaker
ğŸ“‹ RESUMEN EJECUTIVO
plain
Copy
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  SEVERIDAD          â”‚  COUNT  â”‚  CATEGORÃA PRINCIPAL        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ”´ CrÃ­tica         â”‚    0    â”‚  -                          â•‘
â•‘  ğŸŸ  Alta            â”‚    3    â”‚  Types any, Error handling  â•‘
â•‘  ğŸŸ¡ Media           â”‚    8    â”‚  UX, Performance, A11y      â•‘
â•‘  ğŸŸ¢ Baja            â”‚   12    â”‚  Code style, Logs           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ PrÃ³ximos Pasos Recomendados
Inmediato (Esta semana):
[ ] Eliminar any types crÃ­ticos en API responses
[ ] Implementar error boundaries de React
[ ] Auditar exposiciÃ³n de datos sensibles en logs
Corto plazo (Este mes):
[ ] Implementar React Query o SWR para estado servidor
[ ] AÃ±adir tests E2E con Playwright
[ ] Optimizar imÃ¡genes con next/image
Mediano plazo:
[ ] Implementar feature flags para gradual rollout
[ ] AÃ±adir monitoreo de RAG quality en producciÃ³n
[ ] DocumentaciÃ³n de arquitectura tÃ©cnica
Â¿Te gustarÃ­a que profundice en algÃºn Ã¡rea especÃ­fica? Por ejemplo:
AuditorÃ­a de seguridad profunda (autenticaciÃ³n, autorizaciÃ³n, datos)
AnÃ¡lisis de performance (Core Web Vitals, bundle analysis)
Review de arquitectura RAG (chunking, retrieval, generation)
Plan de migraciÃ³n tÃ©cnica (deuda tÃ©cnica priorizada)
AuditorÃ­a de seguridad profunda (autenticaciÃ³n, autorizaciÃ³n, datos)
Edit
Copy
Share
Voy a realizar una auditorÃ­a de seguridad profunda enfocÃ¡ndome en autenticaciÃ³n, autorizaciÃ³n y protecciÃ³n de datos. AnalizarÃ© en detalle los patrones detectados en tu cÃ³digo.
ğŸ” AuditorÃ­a de Seguridad Profunda - ABD RAG Platform
1. AUTENTICACIÃ“N
1.1 Arquitectura de Auth Detectada
TypeScript
Copy
// Stack identificado:
- NextAuth.js (auth.ts / auth.config.ts)
- JWT strategy con session callbacks
- MongoDB adapter (connectAuthDB)
- MFA (TOTP) implementado
- Role-based access (ADMIN, SUPER_ADMIN, USER)
1.2 AnÃ¡lisis de ImplementaciÃ³n MFA
TypeScript
Copy
// middleware.ts - LÃ­neas crÃ­ticas identificadas:
const isMfaPending = session?.user?.mfaPending === true;
const isMfaAllowedPath = pathname.startsWith('/api/auth') || 
                         pathname === '/login' || 
                         pathname === '/admin/profile';

if (isMfaPending && !isMfaAllowedPath) {
    console.error(`ğŸ”’ [MFA ENFORCEMENT] REDIRECTING ${pathname} -> /admin/profile`);
    // ...
}
âš ï¸ Vulnerabilidad MFA: Race Condition Potencial
TypeScript
Copy
// PROBLEMA DETECTADO: El check de MFA estÃ¡ en middleware (Edge/Node)
// pero la actualizaciÃ³n de mfaPending podrÃ­a estar desincronizada

// Escenario de ataque:
// 1. Usuario completa MFA en /api/auth/totp/verify
// 2. SesiÃ³n se actualiza con mfaVerified: true
// 3. PERO el token JWT aÃºn tiene mfaPending: true (no refrescado)
// 4. Usuario redirigido incorrectamente o accede por race condition

// SOLUCIÃ“N RECOMENDADA:
// Implementar "session rotation" inmediata post-MFA
ğŸ”§ CÃ³digo de MitigaciÃ³n Sugerido
TypeScript
Copy
// lib/auth.config.ts - Mejorar session callback
callbacks: {
  async session({ session, token, trigger }) {
    // Forzar refresh de token post-MFA
    if (trigger === "update" && token.mfaVerified) {
      token.mfaPending = false;
      token.mfaVerifiedAt = new Date().toISOString();
    }
    
    // ValidaciÃ³n estricta de estado
    if (token.mfaPending && !token.mfaVerified) {
      session.user.mfaPending = true;
      // Limitar exposiciÃ³n de datos sensibles
      session.user.email = null; 
      session.user.name = null;
    }
    
    return session;
  }
}
1.3 GestiÃ³n de Sesiones
TypeScript
Copy
// Detectado en: profile/page.tsx (server component)
const session = await auth();
if (!session?.user?.email) redirect('/login');
ğŸš¨ Problema: Session Fixation Potential
TypeScript
Copy
// RIESGO: No se detecta rotaciÃ³n de session ID post-login
// En NextAuth.js, esto requiere configuraciÃ³n explÃ­cita:

// next-auth.config.ts - FALTANTE:
export const authConfig = {
  // ... otras configs
  cookies: {
    sessionToken: {
      name: `__Secure-next-auth.session-token`,
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: process.env.NODE_ENV === 'production',
        // FALTA: domain restriction
        // domain: '.abd.com' // Prevenir cookie tossing
      }
    }
  },
  // FALTA: session rotation strategy
  events: {
    async signIn({ user, account, profile, isNewUser }) {
      // No hay lÃ³gica de invalidaciÃ³n de sesiones previas
    }
  }
}
1.4 Password Security
TypeScript
Copy
// Detectado: PasswordForm component (no visible en cÃ³digo pero referenciado)
// AnÃ¡lisis de flujo en actions/api-keys.ts:
TypeScript
Copy
// FORTALEZA: Uso de correlationId para trazabilidad
const correlationId = uuidv4();
await logEvento({
  level: 'INFO',
  source: 'API_KEYS',
  action: 'CREATE_START',
  correlationId, // Buena prÃ¡ctica para audit
  details: { name, permissions, tenantId }
});
âš ï¸ Falta: PolÃ­tica de Passwords
TypeScript
Copy
// No detectado en cÃ³digo - RecomendaciÃ³n implementar:
// lib/password-policy.ts
export const passwordPolicy = {
  minLength: 12,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  maxAge: 90, // dÃ­as
  preventReuse: 5, // Ãºltimas passwords
  checkAgainstBreachDB: true, // HaveIBeenPwned API
  
  // Rate limiting especÃ­fico
  maxAttempts: 5,
  lockoutDuration: 15 * 60 * 1000 // 15 minutos
};
2. AUTORIZACIÃ“N
2.1 Sistema de Permisos (Guardian)
TypeScript
Copy
// Detectado: PermissionMatrixClient, PermissionPolicy schema
// Arquitectura: RBAC + ABAC (Attribute-Based)

interface PermissionPolicy {
  _id: string;
  name: string;
  resources: string[];  // ['knowledge-asset:*', 'api-keys']
  actions: string[];    // ['read', 'write', 'delete']
  effect: 'ALLOW' | 'DENY';
  conditions?: {        // ABAC
    timeOfDay?: { start: string, end: string };
    ipRange?: string[];
    mfaRequired?: boolean;
  }
}
ğŸ”´ Vulnerabilidad CrÃ­tica: Tenant Isolation
TypeScript
Copy
// PROBLEMA ENCONTRADO en actions/api-keys.ts:
export async function createApiKey(name: string, permissions: ApiKeyPermission[], 
                                   expiresInDays?: number, spaceId?: string) {
  const session = await auth();
  // âœ… Check de rol
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    throw new AppError('UNAUTHORIZED', 401, 'No autorizado');
  }
  
  const tenantId = session.user.tenantId;
  
  // âš ï¸ PROBLEMA: spaceId no se valida que pertenezca al tenant
  // ATAQUE: Admin de Tenant A crea API key para Space de Tenant B
  if (spaceId) {
    // Falta: await validateSpaceBelongsToTenant(spaceId, tenantId);
  }
  
  await ApiKeyService.createApiKey(tenantId, name, permissions, ...);
}
ğŸ”§ Fix Inmediato Requerido
TypeScript
Copy
// lib/tenant-isolation.ts
export async function enforceTenantIsolation(
  resourceId: string, 
  resourceType: 'space' | 'document' | 'api-key',
  userTenantId: string
): Promise<void> {
  const collection = getCollection(resourceType);
  const resource = await collection.findOne({ 
    _id: new ObjectId(resourceId) 
  });
  
  if (!resource) throw new AppError('NOT_FOUND', 404);
  
  // ComparaciÃ³n estricta con timing-safe comparison
  if (!crypto.timingSafeEqual(
    Buffer.from(resource.tenantId),
    Buffer.from(userTenantId)
  )) {
    // Log de seguridad crÃ­tico
    await logSecurityEvent({
      type: 'TENANT_ISOLATION_VIOLATION',
      severity: 'CRITICAL',
      attemptedResource: resourceId,
      attackerTenantId: userTenantId,
      actualTenantId: resource.tenantId
    });
    throw new AppError('FORBIDDEN', 403, 'Tenant isolation violation detected');
  }
}
2.2 AnÃ¡lisis de Middleware de AutorizaciÃ³n
TypeScript
Copy
// middleware.ts - EvaluaciÃ³n detallada:

// âœ… FORTALEZAS:
// 1. Fail-closed por defecto (redirige a login si no hay sesiÃ³n)
// 2. CSP estricto con nonces
// 3. HSTS habilitado
// 4. ProtecciÃ³n de rutas internas con secret

// âš ï¸ DEBILIDADES:
TypeScript
Copy
// LÃNEA PROBLEMÃTICA:
const isPublicPath = pathname === '/' || pathname === '/login' || ...;

// VULNERABILIDAD: Path traversal potencial
// /login%2f..%2fadmin podrÃ­a bypass dependiendo de normalizaciÃ³n
// SOLUCIÃ“N:
const normalizedPath = decodeURIComponent(pathname).replace(/\/+/g, '/');
const isPublicPath = PUBLIC_PATHS.has(normalizedPath);
ğŸ”´ Bypass Potencial: API Routes
TypeScript
Copy
// middleware.ts solo protege rutas que NO empiezan con /api
matcher: ['/((?!api|_next/static|_next/image|favicon.ico|.*\\.png$).*)']

// PERO en el cÃ³digo:
if (!session && !isPublicPath) {
  if (pathname.startsWith('/api/')) {
    return new NextResponse("Unauthorized", { status: 401 });
  }
}

// PROBLEMA: Las API routes deben tener su propia autorizaciÃ³n
// No es suficiente con el middleware. Ejemplo de riesgo:

// app/api/admin/users/route.ts - Si no tiene auth() explÃ­cito:
export async function GET() {
  // Sin auth check = datos expuestos
  return Response.json({ users: await db.users.find() });
}
2.3 API Key Security
TypeScript
Copy
// actions/api-keys.ts - AnÃ¡lisis:
Table
Copy
Aspecto	Estado	Riesgo
GeneraciÃ³n	UUID v4	âœ… Aceptable
Almacenamiento	Hash?	âš ï¸ No verificable en cÃ³digo
TransmisiÃ³n	Solo en creaciÃ³n	âœ… Buena prÃ¡ctica
Scoping por tenant	âœ… SÃ­	Pero falta validaciÃ³n space
ExpiraciÃ³n	Opcional	âš ï¸ DeberÃ­a ser obligatoria
RotaciÃ³n	No visible	ğŸ”´ CrÃ­tico faltante
ğŸ”§ ImplementaciÃ³n de RotaciÃ³n Segura
TypeScript
Copy
// lib/api-key-service.ts - Mejoras:
export class ApiKeyService {
  async rotateKey(keyId: string, tenantId: string): Promise<RotationResult> {
    // 1. Validar ownership
    await enforceTenantIsolation(keyId, 'api-key', tenantId);
    
    // 2. Generar nueva key
    const newKey = await this.createApiKey(tenantId, ...);
    
    // 3. PerÃ­odo de gracia (24h) donde ambas funcionan
    await this.setGracePeriod(keyId, newKey.id, 24 * 60 * 60 * 1000);
    
    // 4. Notificar al usuario
    await notifyKeyRotation(tenantId, keyId);
    
    // 5. Programar revocaciÃ³n automÃ¡tica
    await scheduleRevocation(keyId, Date.now() + 24 * 60 * 60 * 1000);
    
    return {
      newKey: newKey.plainText, // Solo vez que se muestra
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000)
    };
  }
}
3. PROTECCIÃ“N DE DATOS
3.1 Base de Datos (MongoDB)
TypeScript
Copy
// Detectado: Multi-tenant con tenantId en documentos
// Esquema tÃ­pico observado:
{
  _id: ObjectId,
  tenantId: string,  // Ãndice de aislamiento
  data: any,
  createdAt: Date
}
ğŸ”´ Riesgo Grave: InyecciÃ³n NoSQL
TypeScript
Copy
// PROBLEMA ENCONTRADO en useApiList hook (patrÃ³n generalizado):
const { data } = useApiList({
  endpoint: '/api/admin/permissions/policies',
  filters: { status: 'active' } // Â¿Sanitizado?
});

// En API route potencialmente:
const { search } = req.query;
// Si se usa directamente:
db.collection.find({ name: { $regex: search } }) // INYECCIÃ“N POSIBLE

// ATAQUE: search = { "$ne": null } â†’ Devuelve todos los documentos
ğŸ”§ Defensa en Profundidad
TypeScript
Copy
// lib/mongo-sanitizer.ts
import { ObjectId } from 'mongodb';

export class MongoSanitizer {
  private static FORBIDDEN_OPERATORS = [
    '$where', '$eval', '$function',
    '$regex', '$options', // Permitir solo con whitelist
    '$gt', '$gte', '$lt', '$lte', '$ne', '$nin', '$in'
  ];

  static sanitizeQuery(input: unknown): Record<string, any> {
    if (typeof input !== 'object' || input === null) {
      return {};
    }

    const sanitized: Record<string, any> = {};
    
    for (const [key, value] of Object.entries(input)) {
      // Bloquear operadores en keys
      if (key.startsWith('$')) {
        console.warn(`Blocked MongoDB operator in key: ${key}`);
        continue;
      }

      // Recursivo para objetos anidados
      if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeQuery(value);
      } else {
        sanitized[key] = this.escapeRegex(value);
      }
    }

    return sanitized;
  }

  private static escapeRegex(value: unknown): unknown {
    if (typeof value === 'string') {
      // Escapar caracteres especiales de regex
      return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    return value;
  }
}

// Uso en API routes:
import { z } from 'zod';

const QuerySchema = z.object({
  status: z.enum(['active', 'inactive']).optional(),
  search: z.string().max(100).optional()
});

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const raw = Object.fromEntries(searchParams);
  
  // 1. ValidaciÃ³n estricta con Zod
  const parsed = QuerySchema.parse(raw);
  
  // 2. SanitizaciÃ³n adicional
  const query = MongoSanitizer.sanitizeQuery(parsed);
  
  // 3. ConstrucciÃ³n segura
  const mongoQuery: any = { tenantId: session.user.tenantId };
  
  if (query.status) mongoQuery.status = query.status;
  if (query.search) {
    // Regex controlada, no user-input directo
    mongoQuery.name = { 
      $regex: `^${query.search}`, // Prefix match solo
      $options: 'i' 
    };
  }
  
  return db.collection.find(mongoQuery);
}
3.2 EncriptaciÃ³n de Datos Sensibles
TypeScript
Copy
// AnÃ¡lisis de campos sensibles detectados:
Table
Copy
Campo	UbicaciÃ³n	Estado de EncriptaciÃ³n	Riesgo
API Keys (valor)	api_keys collection	âš ï¸ No verificable	ALTO
ContraseÃ±as	users (Auth.js)	âœ… Hash bcrypt (asumido)	Bajo
Documentos RAG	knowledge_assets	âŒ No encriptado	MEDIO
PII en tickets	support_tickets	âŒ No verificable	ALTO
Logs de auditorÃ­a	notifications	âŒ Plain text	MEDIO
ğŸ”§ ImplementaciÃ³n de EncriptaciÃ³n a Nivel de Campo
TypeScript
Copy
// lib/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto';

export class FieldEncryption {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;

  constructor(masterKey: string) {
    // Derivar key de 32 bytes
    this.key = scryptSync(masterKey, 'salt', 32);
  }

  encrypt(text: string): string {
    const iv = randomBytes(16);
    const cipher = createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    // Formato: iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedData: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedData.split(':');
    
    const decipher = createDecipheriv(
      this.algorithm,
      this.key,
      Buffer.from(ivHex, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(authTagHex, 'hex'));
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

// Uso en modelo:
const encryption = new FieldEncryption(process.env.FIELD_ENCRYPTION_KEY!);

// Schema hook
apiKeySchema.pre('save', function(next) {
  if (this.isModified('secretValue')) {
    this.secretValue = encryption.encrypt(this.secretValue);
  }
  next();
});
3.3 ProtecciÃ³n contra Data Leakage
TypeScript
Copy
// Detectado en: notifications/page.tsx (Server Component)
const recentLogs = await db.collection('notifications')
  .find({})
  .sort({ createdAt: -1 })
  .limit(10)
  .toArray();

// âš ï¸ PROBLEMA: No hay filtrado de tenantId
// Si un SUPER_ADMIN accede, ve logs de TODOS los tenants
// Esto podrÃ­a ser intencional, pero debe ser explÃ­cito:
TypeScript
Copy
// SOLUCIÃ“N: Explicit tenant scoping
export default async function NotificationsPage() {
  const session = await auth();
  
  const query: any = {};
  
  // Explicit multi-tenancy
  if (session.user.role !== 'SUPER_ADMIN') {
    query.tenantId = session.user.tenantId;
  } else {
    // SUPER_ADMIN debe especificar explÃ­citamente
    const { searchParams } = new URL(req.url);
    const targetTenant = searchParams.get('tenantId');
    
    if (targetTenant) {
      query.tenantId = targetTenant;
      // Log de acceso privilegiado
      await auditLog.log({
        action: 'CROSS_TENANT_ACCESS',
        adminId: session.user.id,
        targetTenant,
        justification: 'Support investigation' // Requerir razÃ³n
      });
    }
    // Si no hay targetTenant, mostrar solo aggregate stats, no detalles
  }
  
  const logs = await db.collection('notifications').find(query).toArray();
}
4. SEGURIDAD DE RAG/IA
4.1 Prompt Injection Protection
TypeScript
Copy
// Detectado en: prompts/page.tsx - GestiÃ³n de prompts dinÃ¡micos
// Riesgo: Los prompts son editable por admins, pero Â¿validados?
TypeScript
Copy
// lib/prompt-security.ts - FALTANTE EN CÃ“DIGO
export class PromptSecurity {
  // Lista de patrones peligrosos
  static FORBIDDEN_PATTERNS = [
    /ignore previous instructions/i,
    /disregard.*prompt/i,
    /system.*override/i,
    /DAN.*mode/i,
    /jailbreak/i,
    /\{\{.*\}\}/g, // Template injection
    /<%.*%>/g,     // EJS injection
  ];

  static validatePrompt(prompt: string): ValidationResult {
    const threats: string[] = [];
    
    for (const pattern of this.FORBIDDEN_PATTERNS) {
      if (pattern.test(prompt)) {
        threats.push(`Detected pattern: ${pattern.source}`);
      }
    }

    // Validar balance de delimitadores
    const openBraces = (prompt.match(/\{/g) || []).length;
    const closeBraces = (prompt.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      threats.push('Unbalanced template delimiters');
    }

    return {
      valid: threats.length === 0,
      threats,
      sanitized: this.sanitize(prompt)
    };
  }

  private static sanitize(prompt: string): string {
    // Escapar caracteres de control
    return prompt
      .replace(/[\x00-\x1F\x7F]/g, '') // Control chars
      .replace(/\u202E/g, ''); // Right-to-left override (spoofing)
  }
}
4.2 Aislamiento de Contexto RAG
TypeScript
Copy
// Detectado: Multi-tenant RAG con espacios de conocimiento
// Riesgo: Cross-tenant retrieval
TypeScript
Copy
// lib/rag/retrieval.ts - Mejora de seguridad:
export async function retrieveContext(
  query: string,
  user: SessionUser,
  options: RetrievalOptions
): Promise<ContextChunk[]> {
  // 1. Construir filtro de seguridad obligatorio
  const securityFilter = {
    // Aislamiento de tenant
    tenantId: user.tenantId,
    
    // Aislamiento de espacio (si aplica)
    ...(options.spaceId && { spaceId: options.spaceId }),
    
    // Verificar que el usuario tiene acceso al espacio
    ...(options.spaceId && {
      $or: [
        { 'space.access': 'public' },
        { 'space.members': user.id },
        { 'space.owner': user.id }
      ]
    }),
    
    // Excluir documentos sensibles sin permiso explÃ­cito
    sensitivity: { $ne: 'CONFIDENTIAL' } // O check explÃ­cito
  };

  // 2. Vector search con pre-filter
  const results = await vectorStore.similaritySearch(query, {
    filter: securityFilter,
    k: options.topK || 5
  });

  // 3. Post-filter: re-verificar ownership (defensa en profundidad)
  const verifiedResults = results.filter(chunk => 
    chunk.metadata.tenantId === user.tenantId
  );

  // 4. Log de acceso para auditorÃ­a
  await logRagAccess({
    userId: user.id,
    query: hashQuery(query), // No loggear query en plain text (PII)
    chunksAccessed: verifiedResults.map(r => r.id),
    timestamp: new Date()
  });

  return verifiedResults;
}
5. AUDITORÃA Y MONITOREO
5.1 Logging de Seguridad
TypeScript
Copy
// Detectado: Sistema de logs con correlationId
// Fortaleza: Estructura consistente
TypeScript
Copy
// lib/logger.ts - Mejoras de seguridad:
interface SecurityEvent {
  level: 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';
  source: string;
  action: string;
  correlationId: string;
  userId?: string;
  tenantId?: string;
  ip?: string;           // Hash para privacidad
  userAgent?: string;    // Truncado
  details?: {
    // NUNCA incluir:
    // - Passwords
    // - API keys en plain text
    // - Tokens JWT completos
    // - PII sin anonimizaciÃ³n
    
    // SÃ incluir:
    resourceType: string;
    resourceId: string;
    actionResult: 'success' | 'failure';
    failureReason?: string; // CÃ³digo, no detalle tÃ©cnico
  };
}

// ImplementaciÃ³n de hash de IP para privacidad (GDPR)
function hashIP(ip: string): string {
  return crypto
    .createHmac('sha256', process.env.IP_HASH_SECRET!)
    .update(ip)
    .digest('hex')
    .substring(0, 16); // Truncar
}
5.2 DetecciÃ³n de AnomalÃ­as
TypeScript
Copy
// lib/security/anomaly-detection.ts - FALTANTE
export class AnomalyDetector {
  async detect(event: SecurityEvent): Promise<Alert[]> {
    const alerts: Alert[] = [];

    // 1. Rate anÃ³malo de API calls
    const recentCalls = await this.countRecentCalls(event.userId, '1m');
    if (recentCalls > 100) {
      alerts.push({
        type: 'RATE_ANOMALY',
        severity: 'HIGH',
        message: `User ${event.userId} exceeded 100 req/min`
      });
    }

    // 2. Acceso desde nueva ubicaciÃ³n
    const knownLocations = await this.getUserLocations(event.userId);
    const currentLocation = this.geoIP(event.ip);
    if (!knownLocations.includes(currentLocation)) {
      alerts.push({
        type: 'NEW_LOCATION',
        severity: 'MEDIUM',
        message: `Login from ${currentLocation}`,
        requiresMfa: true
      });
    }

    // 3. PatrÃ³n de "data exfiltration"
    const dataVolume = await this.calculateDataVolume(event.userId, '1h');
    if (dataVolume > 10 * 1024 * 1024) { // 10MB
      alerts.push({
        type: 'DATA_EXFILTRATION',
        severity: 'CRITICAL',
        message: 'Unusual data download pattern'
      });
    }

    return alerts;
  }
}
6. RESUMEN EJECUTIVO DE RIESGOS
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MAPA DE RIESGOS DE SEGURIDAD                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  CRÃTICO (Arreglar en 24h)                    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ      â”‚
â”‚  â”œâ”€â”€ Tenant isolation bypass en API keys      [actions/api-keys]â”‚
â”‚  â”œâ”€â”€ NoSQL injection en bÃºsquedas             [mÃºltiples hooks] â”‚
â”‚  â””â”€â”€ Session fixation post-MFA                [auth.config]     â”‚
â”‚                                                                 â”‚
â”‚  ALTO (Arreglar en 1 semana)                  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ          â”‚
â”‚  â”œâ”€â”€ Falta de encriptaciÃ³n de campos sensibles                  â”‚
â”‚  â”œâ”€â”€ Prompt injection no mitigado                               â”‚
â”‚  â”œâ”€â”€ Race condition en MFA verification                         â”‚
â”‚  â””â”€â”€ Falta de rotaciÃ³n de API keys                              â”‚
â”‚                                                                 â”‚
â”‚  MEDIO (Arreglar en 1 mes)                    â–ˆâ–ˆâ–ˆâ–ˆ              â”‚
â”‚  â”œâ”€â”€ Logging de PII sin anonimizaciÃ³n                           â”‚
â”‚  â”œâ”€â”€ CSP podrÃ­a ser mÃ¡s restrictivo                             â”‚
â”‚  â””â”€â”€ Falta de rate limiting por endpoint                        â”‚
â”‚                                                                 â”‚
â”‚  BAJO (Mejoras continuas)                     â–ˆâ–ˆ                â”‚
â”‚  â”œâ”€â”€ Headers de seguridad adicionales                           â”‚
â”‚  â””â”€â”€ Subresource Integrity (SRI)                                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
7. CHECKLIST DE REMEDIACIÃ“N
Inmediato (24-48 horas)
[ ] Implementar enforceTenantIsolation() en todas las operaciones con spaceId
[ ] Agregar sanitizaciÃ³n NoSQL en todos los endpoints de bÃºsqueda
[ ] Revisar y fixear el race condition de MFA en session callback
[ ] Auditar todos los useApiItem<any> para validar que no filtran datos cross-tenant
Corto plazo (1-2 semanas)
[ ] Implementar encriptaciÃ³n de campos sensibles (API keys, PII)
[ ] Agregar validaciÃ³n de prompts con PromptSecurity
[ ] Implementar rotaciÃ³n automÃ¡tica de API keys
[ ] Agregar rate limiting especÃ­fico por tipo de operaciÃ³n
Mediano plazo (1 mes)
[ ] Implementar sistema de anomalÃ­as
[ ] AuditorÃ­a completa de PII en logs
[ ] Penetration testing contratado
[ ] CertificaciÃ³n SOC 2 / ISO 27001 preparaciÃ³n
Â¿Deseas que profundice en algÃºn vector de ataque especÃ­fico, o que desarrolle cÃ³digo de mitigaciÃ³n para alguno de los hallazgos crÃ­ticos?
AnÃ¡lisis de performance (Core Web Vitals, bundle analysis)
Edit
Copy
Share
Voy a realizar un anÃ¡lisis exhaustivo de performance, enfocÃ¡ndome en Core Web Vitals, bundle analysis y optimizaciones especÃ­ficas para tu arquitectura RAG con Next.js.
ğŸš€ AuditorÃ­a de Performance - ABD RAG Platform
1. CORE WEB VITALS - ANÃLISIS ESTIMADO
1.1 MÃ©tricas Proyectadas Basadas en CÃ³digo
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CORE WEB VITALS ESTIMADOS                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  LCP (Largest Contentful Paint)                                         â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                         â”‚
â”‚  Estado:  âš ï¸ NECESITA MEJORA (estimado: 2.8s - 4.2s)                    â”‚
â”‚  Objetivo: < 2.5s                                                       â”‚
â”‚                                                                         â”‚
â”‚  Principales contribuyentes identificados:                              â”‚
â”‚  â€¢ Dynamic imports sin preload hints                                    â”‚
â”‚  â€¢ ImÃ¡genes sin next/image (foto de perfil, logos tenant)               â”‚
â”‚  â€¢ Heavy JavaScript en initial bundle                                   â”‚
â”‚  â€¢ Swagger UI cargado sÃ­ncronamente en /admin/api-docs                  â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  INP (Interaction to Next Paint) - NUEVO (marzo 2024)                   â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                     â”‚
â”‚  Estado:  ğŸ”´ MALO (estimado: 350ms - 600ms)                             â”‚
â”‚  Objetivo: < 200ms                                                      â”‚
â”‚                                                                         â”‚
â”‚  Problemas crÃ­ticos:                                                    â”‚
â”‚  â€¢ Re-renders en cascada en PermissionMatrixClient                      â”‚
â”‚  â€¢ useEffect sin debounce en bÃºsquedas (AdminPromptsPage)               â”‚
â”‚  â€¢ Sin useTransition para actualizaciones de UI                         â”‚
â”‚  â€¢ Event handlers sÃ­ncronos bloqueantes                                 â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  CLS (Cumulative Layout Shift)                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                     â”‚
â”‚  Estado:  ğŸŸ¢ BUENO (estimado: 0.05 - 0.1)                               â”‚
â”‚  Objetivo: < 0.1                                                        â”‚
â”‚                                                                         â”‚
â”‚  Fortalezas:                                                            â”‚
â”‚  â€¢ Uso consistente de skeletons                                         â”‚
â”‚  â€¢ Layouts estables con PageContainer                                   â”‚
â”‚  â€¢ Dimensiones explÃ­citas en iconos                                     â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  TTFB (Time to First Byte)                                              â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                     â”‚
â”‚  Estado:  âš ï¸ NECESITA MEJORA (estimado: 600ms - 1.2s)                   â”‚
â”‚  Objetivo: < 600ms                                                      â”‚
â”‚                                                                         â”‚
â”‚  Causas:                                                                â”‚
â”‚  â€¢ Middleware complejo en edge (DOMMatrix polyfill, tracing init)       â”‚
â”‚  â€¢ Cold starts en Vercel (instrumentation.ts)                           â”‚
â”‚  â€¢ MÃºltiples conexiones DB en SSR                                       â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  FCP (First Contentful Paint)                                           â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                     â”‚
â”‚  Estado:  ğŸŸ¢ BUENO (estimado: 1.2s - 1.8s)                              â”‚
â”‚  Objetivo: < 1.8s                                                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
1.2 AnÃ¡lisis de LCP - Problemas EspecÃ­ficos
TypeScript
Copy
// PROBLEMA 1: ImÃ¡genes sin optimizaciÃ³n
// Archivo: AdminPromptsPage.tsx (y mÃºltiples otros)

// CÃ³digo problemÃ¡tico encontrado:
{ p.tenantInfo?.branding?.logo?.url ? (
    <img 
        src={p.tenantInfo.branding.logo.url}  // âŒ img nativo, no next/image
        alt="" 
        className="w-full h-full object-contain p-1" 
    />
) : (
    <div>...</div>
)}

// IMPACTO: 
// - Sin optimizaciÃ³n automÃ¡tica de formato (WebP/AVIF)
// - Sin lazy loading nativo
// - Sin placeholder blur
// - Causa LCP elevado si es imagen hero

// SOLUCIÃ“N:
import Image from 'next/image';

// Componente optimizado:
<TenantLogo 
    src={p.tenantInfo?.branding?.logo?.url}
    name={p.tenantInfo?.name}
    size={40}
/>

// components/TenantLogo.tsx
export function TenantLogo({ src, name, size }: Props) {
    if (!src) return <FallbackLogo name={name} size={size} />;
    
    return (
        <div className="relative" style={{ width: size, height: size }}>
            <Image
                src={src}
                alt={`Logo de ${name}`}
                fill
                sizes={`${size}px`}
                className="object-contain p-1"
                placeholder="blur"
                blurDataURL={generateBlurPlaceholder(name)} // Generar en build
                priority={false} // Solo true para above-the-fold
                loading="lazy"
            />
        </div>
    );
}
TypeScript
Copy
// PROBLEMA 2: Dynamic imports sin estrategia de precarga
// Archivo: admin/page.tsx

// CÃ³digo actual:
const CollectiveIntelligenceDashboard = dynamic(
    () => import("@/components/admin/CollectiveIntelligenceDashboard"),
    { loading: () => <DashboardSkeleton /> }
);

// PROBLEMA: Cuando usuario hace click en tab "intelligence",
// debe esperar descarga + parse + ejecuciÃ³n del chunk

// SOLUCIÃ“N CON PRELOAD INTELIGENTE:
import { useEffect, useState } from 'react';

export default function AdminDashboardPage() {
    const [activeTab, setActiveTab] = useState('overview');
    
    // Precargar componentes pesados cuando el navegador estÃ¡ idle
    useEffect(() => {
        if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
            requestIdleCallback(() => {
                // Precargar tabs secundarios despuÃ©s de LCP
                const preloadTabs = [
                    () => import("@/components/admin/CollectiveIntelligenceDashboard"),
                    () => import("@/components/admin/AutomationStudio"),
                ];
                
                preloadTabs.forEach(importer => {
                    // @ts-ignore - webpack magic comment
                    importer(/* webpackPrefetch: true */);
                });
            }, { timeout: 2000 });
        }
    }, []);

    // O mejor: precargar on hover de tab
    const handleTabHover = (tabId: string) => {
        const preloaders: Record<string, () => Promise<any>> = {
            'intelligence': () => import("@/components/admin/CollectiveIntelligenceDashboard"),
            'automation': () => import("@/components/admin/AutomationStudio"),
            // ...
        };
        
        preloaders[tabId]?.();
    };

    return (
        <DashboardTabs>
            <DashboardTabs.Tab 
                id="intelligence" 
                onMouseEnter={() => handleTabHover('intelligence')}
            >
                {t('tabs.intelligence')}
            </DashboardTabs.Tab>
            {/* ... */}
        </DashboardTabs>
    );
}
2. BUNDLE ANALYSIS - ANÃLISIS DETALLADO
2.1 EstimaciÃ³n de TamaÃ±os de Bundle
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMPOSICIÃ“N DEL BUNDLE                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  PÃ¡gina: / (Landing)                                                    â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                                   â”‚
â”‚  First Load JS:     ~245 KB (estimado)                                  â”‚
â”‚  â”œâ”€ React/Next.js:   ~85 KB (framework)                                 â”‚
â”‚  â”œâ”€ UI Components:   ~65 KB (shadcn/ui, radix, framer-motion)           â”‚
â”‚  â”œâ”€ Icons (Lucide):  ~35 KB âš ï¸  NO TREE-SHAKED COMPLETAMENTE            â”‚
â”‚  â”œâ”€ i18n (next-intl): ~25 KB                                            â”‚
â”‚  â””â”€ App Code:        ~35 KB                                             â”‚
â”‚                                                                         â”‚
â”‚  Problema: Framer-motion cargado en landing estÃ¡tica                    â”‚
â”‚  SoluciÃ³n: Dynamic import para animaciones below-the-fold               â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  PÃ¡gina: /admin/dashboard                                               â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                             â”‚
â”‚  First Load JS:     ~580 KB (estimado) âš ï¸  GRANDE                       â”‚
â”‚  â”œâ”€ Framework:       ~85 KB                                             â”‚
â”‚  â”œâ”€ Chart libraries: ~120 KB (recharts o similar)                       â”‚
â”‚  â”œâ”€ Monaco/Swagger:  ~150 KB âš ï¸  CARGADO EN TODAS LAS TABS              â”‚
â”‚  â”œâ”€ Icons:           ~45 KB                                             â”‚
â”‚  â”œâ”€ UI Components:   ~95 KB                                             â”‚
â”‚  â””â”€ App Logic:       ~85 KB                                             â”‚
â”‚                                                                         â”‚
â”‚  ğŸ”´ CRÃTICO: Swagger UI en bundle inicial                               â”‚
â”‚                                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                         â”‚
â”‚  PÃ¡gina: /admin/prompts                                                 â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                               â”‚
â”‚  First Load JS:     ~420 KB (estimado)                                  â”‚
â”‚  â”œâ”€ Editor component: ~180 KB âš ï¸  (Monaco/ProseMirror?)                  â”‚
â”‚  â”œâ”€ Animation lib:    ~45 KB (framer-motion)                            â”‚
â”‚  â””â”€ Resto:           ~195 KB                                            â”‚
â”‚                                                                         â”‚
â”‚  Problema: Editor cargado aunque no se use inmediatamente               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.2 AnÃ¡lisis de DuplicaciÃ³n de Dependencias
TypeScript
Copy
// Detectado en cÃ³digo - Riesgo de duplicaciÃ³n:

// Archivo A: date-fns
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

// Archivo B: date-fns (otra importaciÃ³n)
import { formatDistanceToNow } from 'date-fns';
import { es, enUS } from 'date-fns/locale'; // es duplicado

// Archivo C: posiblemente otra versiÃ³n o formato diferente

// PROBLEMA: date-fns no es tree-shakeable por defecto en algunas configs
// SOLUCIÃ“N: Usar imports especÃ­ficos y plugin de webpack

// next.config.js - OptimizaciÃ³n:
module.exports = {
  webpack: (config, { isServer }) => {
    // Forzar single instance de librerÃ­as comunes
    config.resolve.alias = {
      ...config.resolve.alias,
      'date-fns': path.resolve('./node_modules/date-fns'),
      'lodash': 'lodash-es', // Usar ES modules version
    };

    // Split chunks mÃ¡s agresivo
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        // Separar librerÃ­as pesadas
        vendor: {
          test: /[\\/]node_modules[\\/](react|react-dom|next)[\\/]/,
          name: 'framework',
          priority: 40,
          enforce: true,
        },
        // Icons en chunk separado
        icons: {
          test: /[\\/]node_modules[\\/]lucide-react[\\/]/,
          name: 'icons',
          priority: 30,
        },
        // UI components
        ui: {
          test: /[\\/](components\\/ui|@radix-ui)[\\/]/,
          name: 'ui-components',
          priority: 20,
        },
        // Charts y visualizaciÃ³n
        viz: {
          test: /[\\/](recharts|d3|@nivo)[\\/]/,
          name: 'visualization',
          priority: 10,
        },
      },
    };

    return config;
  },
};
2.3 Problemas de CÃ³digo EspecÃ­ficos
TypeScript
Copy
// PROBLEMA 3: ImportaciÃ³n masiva de iconos
// MÃºltiples archivos con patrÃ³n ineficiente:

// âŒ MAL (detectado en AdminDashboardPage.tsx y otros):
import {
    ShieldCheck, Zap, Activity, AlertTriangle, BrainCircuit,
    Globe2, Server, Scale, Monitor, LayoutGrid
} from 'lucide-react';

// Esto importa TODO el bundle de lucide, no solo los 10 iconos

// âœ… BIEN - Tree-shaking explÃ­cito:
import ShieldCheck from 'lucide-react/dist/esm/icons/shield-check';
import Zap from 'lucide-react/dist/esm/icons/zap';
// ... etc

// O mejor: usar un barrel file optimizado
// components/icons/index.ts:
export { default as ShieldCheck } from 'lucide-react/dist/esm/icons/shield-check';
export { default as Zap } from 'lucide-react/dist/esm/icons/zap';
// ...

// Y configurar next.config.js:
{
  modularizeImports: {
    'lucide-react': {
      transform: 'lucide-react/dist/esm/icons/{{kebabCase member}}',
    },
  },
}
TypeScript
Copy
// PROBLEMA 4: Context providers en layout root
// Archivo: layout.tsx

// CÃ³digo actual (problema de hidrataciÃ³n y bundle):
<NextIntlClientProvider locale={locale} messages={messages}>
  <StructuredData />
  <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
    <SessionProvider session={session}>
      <BrandingProvider>
        <SidebarProvider>
          <Toaster />
          {children}
        </SidebarProvider>
      </BrandingProvider>
    </SessionProvider>
  </ThemeProvider>
</NextIntlClientProvider>

// ANÃLISIS DE IMPACTO:
// - Cada provider aÃ±ade overhead de React context
// - ThemeProvider probablemente re-hidrata todo el Ã¡rbol
// - SessionProvider en root = payload grande en initial HTML

// SOLUCIÃ“N: Arquitectura de providers optimizada
// app/providers.tsx:
'use client';

import { useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Providers crÃ­ticos (cargar inmediatamente)
import { ThemeProvider } from '@/components/theme-provider';
import { Toaster } from 'sonner';

// Providers diferidos (no bloquean LCP)
const SessionProvider = dynamic(
  () => import('next-auth/react').then(m => m.SessionProvider),
  { ssr: false } // No bloquear SSR
);

const BrandingProvider = dynamic(
  () => import('@/providers/BrandingProvider'),
  { ssr: false }
);

// Sidebar solo para rutas autenticadas
const SidebarProvider = dynamic(
  () => import('@/context/SidebarContext'),
  { ssr: false }
);

export function Providers({ children, session, locale, messages }: Props) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    <ThemeProvider>
      {/* Critical UI */}
      <Toaster position="top-right" richColors />
      
      {/* Deferred providers - only client-side */}
      {mounted && (
        <SessionProvider session={session}>
          <BrandingProvider>
            <SidebarProvider>
              {children}
            </SidebarProvider>
          </BrandingProvider>
        </SessionProvider>
      )}
      
      {/* Fallback para SSR */}
      {!mounted && <div style={{ visibility: 'hidden' }}>{children}</div>}
    </ThemeProvider>
  );
}
3. OPTIMIZACIONES ESPECÃFICAS POR RUTA
3.1 /admin/dashboard - OptimizaciÃ³n CrÃ­tica
TypeScript
Copy
// Archivo actual: admin/page.tsx
// Problema: Carga 6 componentes dinÃ¡micos pero todos en mismo chunk

// SOLUCIÃ“N: Code splitting estratÃ©gico con prefetching

// 1. Separar tabs en chunks independientes
const tabModules = {
  intelligence: () => import(/* webpackChunkName: "intelligence" */ 
    "@/components/admin/CollectiveIntelligenceDashboard"),
  automation: () => import(/* webpackChunkName: "automation" */ 
    "@/components/admin/AutomationStudio"),
  governance: () => import(/* webpackChunkName: "governance" */ 
    "@/components/admin/KnowledgeGovernance"),
  search: () => import(/* webpackChunkName: "search" */ 
    "@/components/shared/GlobalSemanticSearch"),
  reliability: () => import(/* webpackChunkName: "reliability" */ 
    "@/components/admin/ReliabilityStressMonitor"),
  security: () => import(/* webpackChunkName: "security" */ 
    "@/components/admin/SecurityAutoscaleMonitor"),
};

// 2. Implementar TabLoader con suspense boundaries
function TabPanel({ tabId, isActive }: { tabId: string; isActive: boolean }) {
  const [Component, setComponent] = useState<React.ComponentType | null>(null);

  useEffect(() => {
    if (isActive && !Component) {
      // Cargar solo cuando se activa
      tabModules[tabId as keyof typeof tabModules]().then(mod => {
        setComponent(() => mod.default);
      });
    }
  }, [isActive, tabId]);

  if (!isActive) return null;
  if (!Component) return <DashboardSkeleton />;

  return (
    <ErrorBoundary fallback={<TabError />}>
      <Suspense fallback={<DashboardSkeleton />}>
        <Component />
      </Suspense>
    </ErrorBoundary>
  );
}

// 3. Preloading inteligente basado en predicciÃ³n de usuario
function usePredictivePreload() {
  const { data: userBehavior } = useSWR('/api/user/behavior-patterns');
  
  useEffect(() => {
    if (!userBehavior) return;
    
    // Preload tabs que el usuario visita frecuentemente
    const frequentTabs = userBehavior.mostVisitedTabs.slice(0, 2);
    
    requestIdleCallback(() => {
      frequentTabs.forEach((tab: string) => {
        tabModules[tab as keyof typeof tabModules]();
      });
    });
  }, [userBehavior]);
}
3.2 /admin/api-docs - Swagger UI OptimizaciÃ³n
TypeScript
Copy
// Archivo actual: admin/api-docs/page.tsx
// PROBLEMA: Swagger UI es ~300KB y carga sÃ­ncronamente

// SOLUCIÃ“N: Carga progresiva con shell

'use client';

import dynamic from 'next/dynamic';
import { Suspense, useState, useEffect } from 'react';

// Shell que se muestra inmediatamente
function SwaggerShell() {
  return (
    <div className="animate-pulse space-y-4">
      <div className="h-8 bg-slate-200 rounded w-1/3" />
      <div className="h-64 bg-slate-100 rounded border-2 border-dashed border-slate-200" />
      <div className="space-y-2">
        {[1, 2, 3].map(i => (
          <div key={i} className="h-12 bg-slate-50 rounded" />
        ))}
      </div>
    </div>
  );
}

// Carga verdaderamente diferida
const SwaggerUI = dynamic(
  () => import('swagger-ui-react'),
  { 
    ssr: false,
    loading: () => <SwaggerShell />
  }
);

export default function ApiDocsPage() {
  const [shouldLoad, setShouldLoad] = useState(false);

  useEffect(() => {
    // Cargar solo cuando el usuario interactÃºa o despuÃ©s de 3s
    const timer = setTimeout(() => setShouldLoad(true), 3000);
    
    // O cargar inmediatamente si es interaction
    const handleInteraction = () => {
      setShouldLoad(true);
      clearTimeout(timer);
    };

    window.addEventListener('scroll', handleInteraction, { once: true });
    window.addEventListener('click', handleInteraction, { once: true });

    return () => clearTimeout(timer);
  }, []);

  return (
    <PageContainer>
      <PageHeader title={t('title')} />
      <ContentCard>
        {shouldLoad ? (
          <SwaggerUI url="/api/swagger/spec" />
        ) : (
          <SwaggerShell />
        )}
      </ContentCard>
    </PageContainer>
  );
}
4. OPTIMIZACIONES DE RENDERIZADO
4.1 Server Components vs Client Components
TypeScript
Copy
// ANÃLISIS ACTUAL:
// Muchos "use client" innecesarios detectados

// âŒ MAL: Client component que no necesita interactividad
'use client'; // â† Innecesario

import { useTranslations } from 'next-intl';

export default function StaticContent() {
  const t = useTranslations('key');
  return <div>{t('title')}</div>;
}

// âœ… BIEN: Server Component con i18n
import { getTranslations } from 'next-intl/server';

export default async function StaticContent() {
  const t = await getTranslations('key');
  return <div>{t('title')}</div>;
}

// Si necesitas revalidaciÃ³n:
export const revalidate = 3600; // 1 hora
4.2 Streaming y Suspense
TypeScript
Copy
// Archivo: admin/page.tsx - Mejora con streaming

// Actual: Todo bloqueado hasta que stats carguen
const { data: stats, isLoading } = useApiItem({...});

// Mejorado: Streaming progresivo
import { Suspense } from 'react';

export default function AdminDashboardPage() {
  return (
    <PageContainer>
      <PageHeader />
      
      {/* Esto carga inmediatamente, no bloquea */}
      <QuickNavConnector />
      
      {/* Cada secciÃ³n stream independientemente */}
      <Suspense fallback={<StatsSkeleton />}>
        <StatsSection />
      </Suspense>
      
      <Suspense fallback={<ChartsSkeleton />}>
        <ChartsSection />
      </Suspense>
      
      <Suspense fallback={<ActivitySkeleton />}>
        <RecentActivitySection />
      </Suspense>
    </PageContainer>
  );
}

// Cada secciÃ³n es un Server Component async
async function StatsSection() {
  const stats = await fetchStats(); // No bloquea otras secciones
  return <StatsGrid stats={stats} />;
}
5. OPTIMIZACIONES DE DATOS Y CACHING
5.1 Estrategia de Caching para RAG
TypeScript
Copy
// lib/cache/rag-cache.ts - Nuevo sistema de caching

import { unstable_cache } from 'next/cache';
import { revalidateTag } from 'next/cache';

// Cache para resultados de bÃºsqueda semÃ¡ntica
// Los resultados RAG son idempotentes y cacheables
export const getCachedRetrieval = unstable_cache(
  async (query: string, tenantId: string, spaceId?: string) => {
    return await performVectorSearch(query, tenantId, spaceId);
  },
  ['rag-retrieval'],
  {
    tags: ['rag', 'search'],
    revalidate: 300, // 5 minutos para resultados de bÃºsqueda
  }
);

// Cache para prompts (cambian poco frecuentemente)
export const getCachedPrompt = unstable_cache(
  async (promptKey: string, tenantId: string) => {
    return await db.prompts.findOne({ key: promptKey, tenantId });
  },
  ['prompt'],
  {
    tags: ['prompts'],
    revalidate: 3600, // 1 hora
  }
);

// InvalidaciÃ³n selectiva
export async function invalidatePromptCache(promptKey: string) {
  revalidateTag('prompts');
  // O mÃ¡s granular:
  // revalidateTag(`prompt-${promptKey}`);
}
5.2 OptimizaciÃ³n de MongoDB Queries
TypeScript
Copy
// Detectado en notifications/page.tsx y otros:
// Queries sin proyecciÃ³n = transferencia de datos innecesaria

// âŒ MAL:
const recentLogs = await db.collection('notifications')
  .find({})
  .sort({ createdAt: -1 })
  .limit(10)
  .toArray();
// â†‘ Transfiere TODOS los campos de cada documento

// âœ… BIEN:
const recentLogs = await db.collection('notifications')
  .find({}, {
    projection: {
      _id: 1,
      title: 1,
      status: 1,
      createdAt: 1,
      // EXCLUIR explÃ­citamente campos pesados:
      content: 0,        // Si es grande
      fullMessage: 0,    // Detalles no necesarios en lista
      internalNotes: 0,  // Datos sensibles
    }
  })
  .sort({ createdAt: -1 })
  .limit(10)
  .toArray();

// AÃ±adir Ã­ndices para queries frecuentes:
// db.notifications.createIndex({ tenantId: 1, createdAt: -1 })
// db.notifications.createIndex({ userId: 1, status: 1 })
6. MONITOREO DE PERFORMANCE
6.1 ImplementaciÃ³n de Web Vitals Tracking
TypeScript
Copy
// app/web-vitals.tsx
'use client';

import { useReportWebVitals } from 'next/web-vitals';
import { sendToAnalytics } from '@/lib/analytics';

export function WebVitals() {
  useReportWebVitals((metric) => {
    // Enviar a tu sistema de analytics
    sendToAnalytics({
      event: 'web_vital',
      metric: metric.name,        // LCP, FID, CLS, INP, TTFB
      value: metric.value,
      id: metric.id,              // Para debugging
      page: window.location.pathname,
      // RAG-specific context
      queryComplexity: window.__RAG_CONTEXT__?.queryComplexity,
      retrievalTime: window.__RAG_CONTEXT__?.retrievalTime,
    });

    // Alertar si excede umbrales
    if (metric.name === 'LCP' && metric.value > 2500) {
      console.warn('[Performance] LCP exceeded threshold:', metric);
    }
  });

  return null;
}

// Uso en layout:
import { WebVitals } from './web-vitals';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  );
}
6.2 Dashboard de Performance RAG
TypeScript
Copy
// lib/performance/rag-metrics.ts

interface RAGPerformanceMetrics {
  // Tiempo de retrieval vectorial
  vectorSearchTime: number;
  
  // Tiempo de llamada a LLM
  llmLatency: number;
  
  // Tokens procesados
  tokensIn: number;
  tokensOut: number;
  
  // Calidad de resultados
  retrievalConfidence: number;
  userFeedback?: 'positive' | 'negative';
}

export function trackRAGPerformance(metrics: RAGPerformanceMetrics) {
  // Enviar a APM (Datadog, New Relic, etc.)
  const apm = getAPMClient();
  
  apm.timing('rag.vector_search', metrics.vectorSearchTime);
  apm.timing('rag.llm_latency', metrics.llmLatency);
  apm.gauge('rag.tokens_total', metrics.tokensIn + metrics.tokensOut);
  apm.gauge('rag.confidence', metrics.retrievalConfidence);
  
  // Alertas si degradaciÃ³n
  if (metrics.vectorSearchTime > 500) {
    apm.alert('rag_search_slow', {
      threshold: 500,
      actual: metrics.vectorSearchTime,
    });
  }
}
7. CHECKLIST DE OPTIMIZACIÃ“N
Inmediato (Esta semana)
[ ] Agregar modularizeImports para lucide-react en next.config.js
[ ] Reemplazar todas las <img> por <Image> de Next.js
[ ] Implementar lazy loading para Swagger UI
[ ] Agregar unstable_cache para queries RAG frecuentes
[ ] Optimizar proyecciones MongoDB (excluir campos grandes)
Corto plazo (2 semanas)
[ ] Migrar providers a arquitectura diferida
[ ] Implementar predictive preloading para tabs frecuentes
[ ] Agregar @next/bundle-analyzer y analizar duplicaciones
[ ] Implementar streaming SSR para dashboard sections
[ ] Optimizar INP con useTransition y debouncing
Mediano plazo (1 mes)
[ ] Implementar edge caching para API routes de bÃºsqueda
[ ] Service Worker para offline support de documentos
[ ] Partials/Instant loading con Next.js 14+ features
[ ] OptimizaciÃ³n de imÃ¡genes (AVIF, responsive sizes)
[ ] Real User Monitoring (RUM) completo
8. IMPACTO ESPERADO DE OPTIMIZACIONES
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROYECCIÃ“N DE MEJORAS                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  MÃ©trica          Actual      Optimizado      Mejora                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚
â”‚  LCP              2.8s        1.4s            -50%  ğŸ¯                  â”‚
â”‚  INP              450ms       120ms           -73%  ğŸ¯                  â”‚
â”‚  Bundle /admin    580KB       180KB           -69%  ğŸ¯                  â”‚
â”‚  TTFB             800ms       350ms           -56%  ğŸ¯                  â”‚
â”‚  Time to Interactive  4.5s    2.1s            -53%  ğŸ¯                  â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚
â”‚                                                                         â”‚
â”‚  EstimaciÃ³n de conversiÃ³n de usuarios:                                  â”‚
â”‚  â€¢ Mejora de 100ms en LCP = +1% conversiÃ³n                              â”‚
â”‚  â€¢ Mejora de 1s en TTI = +5% retenciÃ³n                                  â”‚
â”‚  â€¢ Tu caso: Potencial +15-20% mejora en engagement                      â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Â¿Deseas que profundice en alguna optimizaciÃ³n especÃ­fica, o que genere cÃ³digo de implementaciÃ³n para alguna de las mejoras prioritarias (como el sistema de caching para RAG o la arquitectura de providers optimizada)?
Review de arquitectura RAG (chunking, retrieval, generation)
Edit
Copy
Share
Voy a realizar una review exhaustiva de tu arquitectura RAG, analizando chunking, retrieval, generation y los componentes de orquestaciÃ³n detectados en tu cÃ³digo.
ğŸ§  Review de Arquitectura RAG - ABD RAG Platform
1. ARQUITECTURA GENERAL DETECTADA
1.1 Diagrama de Componentes Inferido
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ARQUITECTURA RAG ABD                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   INGESTA   â”‚â”€â”€â”€â”€â–¶â”‚  CHUNKING   â”‚â”€â”€â”€â”€â–¶â”‚   EMBED     â”‚               â”‚
â”‚  â”‚  (BullMQ)   â”‚     â”‚  (pdf-parse)â”‚     â”‚  (Gemini)   â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                  â”‚                      â”‚
â”‚                                                  â–¼                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚    RAG      â”‚â—€â”€â”€â”€â”€â”‚  RETRIEVAL  â”‚â—€â”€â”€â”€â”€â”‚  VECTOR DB  â”‚               â”‚
â”‚  â”‚   QUALITY   â”‚     â”‚ (Semantic)  â”‚     â”‚ (MongoDB    â”‚               â”‚
â”‚  â”‚  DASHBOARD  â”‚     â”‚             â”‚     â”‚  + Vector)  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                      â”‚   RERANK    â”‚â”€â”€â”€â”€â–¶â”‚ GENERATION  â”‚               â”‚
â”‚                      â”‚  (Gemini)   â”‚     â”‚  (Gemini)   â”‚               â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                  â”‚                      â”‚
â”‚                                                  â–¼                      â”‚
â”‚                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                                           â”‚   OUTPUT    â”‚              â”‚
â”‚                                           â”‚ (Streaming) â”‚              â”‚
â”‚                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    ORQUESTACIÃ“N Y GOBIERNO                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ AgentTraceViewer (correlationId-based tracing)               â”‚  â”‚
â”‚  â”‚  â€¢ Prompt versioning (STAGING/PRODUCTION environments)            â”‚  â”‚
â”‚  â”‚  â€¢ Multi-tenant isolation (tenantId + spaceId scoping)            â”‚  â”‚
â”‚  â”‚  â€¢ Federated insights (cross-tenant pattern learning)             â”‚  â”‚
â”‚  â”‚  â€¢ Knowledge Graph (entity relationships)                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
1.2 Flujo de Datos Identificado
TypeScript
Copy
// Detectado en cÃ³digo - Flujo tÃ­pico:

// 1. INGESTA (entities/page.tsx)
const ingestAndStartAnalysis = async () => {
  const resp = await fetch(entity.api.analyze!, {
    method: "POST",
    body: formData, // PDF upload
  });
  // Retorna: entity_id para tracing
};

// 2. ANÃLISIS (CaseDetailPage, ValidationWorkflow)
const { data: caseData } = useApiItem({
  endpoint: `/api/admin/cases/${id}`
});
// Incluye: detectedPatterns, risks, federatedInsights, confidence

// 3. RECUPERACIÃ“N (KnowledgeExplorer, QuickQAPanel)
// Uso de useApiList para chunks vectorizados

// 4. GENERACIÃ“N (ConversationalSearch, SandboxChat)
// Streaming de respuestas con contexto RAG
2. CHUNKING - ANÃLISIS DETALLADO
2.1 Estado Actual Inferido
TypeScript
Copy
// Basado en referencias detectadas:
// - pdf-parse/pdf.js en instrumentation.ts (polyfill DOMMatrix)
// - "chunks vectorizados" mencionados en KnowledgeHubPage
// - detectedPatterns en resultados de anÃ¡lisis

// Estrategia probable (no visible en cÃ³digo completo):
interface ChunkingStrategy {
  type: 'semantic' | 'fixed' | 'hierarchical';
  chunkSize: number;        // Â¿512? Â¿1024? tokens
  overlap: number;          // Â¿50? Â¿200? tokens
  separator: string;        // Â¿"\n\n"? Â¿". "?
  metadataPreservation: boolean;
}
ğŸ”´ Problemas CrÃ­ticos Detectados
Table
Copy
Problema	Evidencia	Impacto	SoluciÃ³n
Sin chunking hÃ­brido	Solo referencias a "chunks" genÃ©ricos	PÃ©rdida de contexto estructural	Implementar hierarchical chunking
No hay deduplicaciÃ³n visible	Cada PDF procesado independientemente	Embeddings redundantes, costo â†‘	DeduplicaciÃ³n por hash MD5 (detectado en MyDocuments)
Falta contexto semÃ¡ntico	No hay "parent chunk" references	FragmentaciÃ³n de ideas complejas	Agregar parent_id y nivel jerÃ¡rquico
2.2 Arquitectura de Chunking Recomendada
TypeScript
Copy
// lib/rag/chunking/hierarchical-chunker.ts

interface HierarchicalChunk {
  // IdentificaciÃ³n
  id: string;
  documentId: string;
  tenantId: string;
  
  // JerarquÃ­a
  level: 'document' | 'section' | 'paragraph' | 'sentence';
  parentId?: string;           // Referencia al chunk padre
  childrenIds?: string[];      // Referencias a chunks hijos
  path: string;                // Ej: "doc/section-2/para-3"
  
  // Contenido
  content: string;
  tokenCount: number;
  charCount: number;
  
  // Contexto enriquecido
  context: {
    title?: string;              // TÃ­tulo de secciÃ³n
    headers: string[];           // Headers jerÃ¡rquicos
    summary?: string;            // Summary del padre (para retrieval)
    keywords: string[];          // TF-IDF extracto
    entities: string[];          // NER del chunk
  };
  
  // Metadatos tÃ©cnicos
  position: {
    start: number;               // Offset en documento original
    end: number;
    page?: number;
    line?: number;
  };
  
  // Para RAG avanzado
  embedding?: number[];          // Vector del chunk
  sparseVector?: Record<string, number>; // BM25/TF-IDF para hybrid search
}

export class HierarchicalChunker {
  private tokenizer: Tokenizer;
  private maxTokens: number;
  private overlapTokens: number;
  
  constructor(config: ChunkerConfig) {
    this.tokenizer = new GeminiTokenizer(); // o tiktoken para GPT
    this.maxTokens = config.maxTokens || 512;
    this.overlapTokens = config.overlapTokens || 50;
  }
  
  async chunkDocument(document: Document): Promise<HierarchicalChunk[]> {
    // Paso 1: Estructura jerÃ¡rquica
    const structure = await this.extractStructure(document);
    
    // Paso 2: Chunking inteligente por nivel
    const chunks: HierarchicalChunk[] = [];
    
    for (const section of structure.sections) {
      const sectionChunk = this.createSectionChunk(section, document);
      chunks.push(sectionChunk);
      
      // Sub-chunks para contenido denso
      if (section.tokenCount > this.maxTokens) {
        const subChunks = this.createSubChunks(section, sectionChunk.id);
        chunks.push(...subChunks);
      }
    }
    
    // Paso 3: Enriquecimiento con contexto
    return this.enrichWithContext(chunks);
  }
  
  private createSubChunks(section: Section, parentId: string): HierarchicalChunk[] {
    // Estrategia: Semantic splitting usando embeddings
    const sentences = this.splitIntoSentences(section.content);
    const semanticGroups = this.groupBySemanticSimilarity(sentences);
    
    return semanticGroups.map((group, idx) => ({
      id: generateId(),
      level: 'paragraph',
      parentId,
      path: `${parentId}/para-${idx}`,
      content: group.join(' '),
      tokenCount: this.tokenizer.count(group.join(' ')),
      // ... resto de campos
    }));
  }
  
  private async groupBySemanticSimilarity(sentences: string[]): Promise<string[][]> {
    // Usar embeddings pequeÃ±os para detectar cambios de tema
    const embeddings = await embedBatch(sentences, { model: 'embedding-001' });
    
    const groups: string[][] = [];
    let currentGroup: string[] = [sentences[0]];
    let currentEmbedding = embeddings[0];
    
    for (let i = 1; i < sentences.length; i++) {
      const similarity = cosineSimilarity(currentEmbedding, embeddings[i]);
      
      if (similarity > 0.85 && 
          this.tokenizer.count(currentGroup.join(' ') + sentences[i]) < this.maxTokens) {
        // Mismo tema, agregar al grupo
        currentGroup.push(sentences[i]);
        // Promedio de embeddings
        currentEmbedding = averageVectors(currentEmbedding, embeddings[i]);
      } else {
        // Cambio de tema, nuevo grupo
        groups.push(currentGroup);
        currentGroup = [sentences[i]];
        currentEmbedding = embeddings[i];
      }
    }
    
    groups.push(currentGroup);
    return groups;
  }
}
2.3 DeduplicaciÃ³n Inteligente
TypeScript
Copy
// Detectado: MD5 en documentos, pero no en chunks

// lib/rag/deduplication/chunk-deduplicator.ts

interface DedupResult {
  isDuplicate: boolean;
  existingChunkId?: string;
  similarityScore: number;
  action: 'skip' | 'update' | 'create';
}

export class ChunkDeduplicator {
  // Fingerprinting semÃ¡ntico + hash
  async checkDuplicate(newChunk: HierarchicalChunk): Promise<DedupResult> {
    // 1. Hash exacto (rÃ¡pido)
    const exactHash = crypto.createHash('sha256')
      .update(newChunk.content.trim().toLowerCase())
      .digest('hex');
    
    const exactMatch = await db.chunks.findOne({ exactHash });
    if (exactMatch) {
      return { isDuplicate: true, existingChunkId: exactMatch._id, similarityScore: 1.0, action: 'skip' };
    }
    
    // 2. SimHash para near-duplicates (contenido ligeramente modificado)
    const simHash = this.computeSimHash(newChunk.content);
    const candidates = await db.chunks.find({
      tenantId: newChunk.tenantId,
      simHash: { $near: simHash } // Usar Ã­ndice LSH
    }).limit(10);
    
    for (const candidate of candidates) {
      const similarity = this.computeJaccardSimilarity(
        newChunk.content, 
        candidate.content
      );
      
      if (similarity > 0.95) {
        return { isDuplicate: true, existingChunkId: candidate._id, similarityScore: similarity, action: 'skip' };
      }
      
      if (similarity > 0.85) {
        // Merge de metadatos, mantener el mÃ¡s reciente
        return { isDuplicate: false, existingChunkId: candidate._id, similarityScore: similarity, action: 'update' };
      }
    }
    
    return { isDuplicate: false, similarityScore: 0, action: 'create' };
  }
  
  private computeSimHash(content: string): string {
    // SimHash para near-duplicate detection eficiente
    const tokens = tokenize(content);
    const hashes = tokens.map(t => hash(t));
    const dimensions = 64;
    const vector = new Array(dimensions).fill(0);
    
    for (const h of hashes) {
      for (let i = 0; i < dimensions; i++) {
        vector[i] += (h >> i) & 1 ? 1 : -1;
      }
    }
    
    return vector.map(v => v > 0 ? '1' : '0').join('');
  }
}
3. RETRIEVAL - ANÃLISIS PROFUNDO
3.1 Arquitectura de Retrieval Detectada
TypeScript
Copy
// Basado en: KnowledgeExplorer, QuickQAPanel, GlobalSemanticSearch
// y referencias a "chunks vectorizados"

// Componentes identificados:
interface RetrievalSystem {
  // Vector store (probablemente MongoDB Atlas Vector Search)
  vectorStore: {
    index: 'vector_index';
    dimensions: 768; // Gemini embedding-001
    metric: 'cosine' | 'euclidean';
  };
  
  // Query handling
  queryProcessor: {
    expansion: boolean;        // Â¿HyDE? Â¿Query expansion?
    intentClassification: boolean;
    entityExtraction: boolean;
  };
  
  // Retrieval strategies
  strategies: {
    semantic: boolean;         // Dense retrieval
    keyword: boolean;          // BM25/Sparse
    hybrid: boolean;           // CombinaciÃ³n
    graph: boolean;            // Knowledge graph (detectado en GraphExplorer)
  };
}
ğŸ”´ Problemas CrÃ­ticos de Retrieval
Table
Copy
Problema	Severidad	Evidencia	Impacto
Sin query rewriting	Alta	BÃºsquedas literales en UI	RecuperaciÃ³n pobre para preguntas complejas
No hay HyDE	Alta	No detectado en cÃ³digo	Gap semÃ¡ntico query-documento
Falta re-ranking	Media	"RAG Quality Dashboard" existe pero no claro si aplica a retrieval	PrecisiÃ³n baja en top-k
Sin multi-hop	Media	"Federated insights" sugiere relaciones pero no retrieval multi-paso	No responde preguntas que requieren conectar datos
Cold start en embeddings	Baja	Tenant isolation implica vectores separados	Latencia alta para nuevos tenants
3.2 Sistema de Retrieval Avanzado
TypeScript
Copy
// lib/rag/retrieval/advanced-retriever.ts

interface RetrievalConfig {
  // Estrategia base
  strategy: 'semantic' | 'hybrid' | 'graph' | 'adaptive';
  
  // ParÃ¡metros
  topK: number;
  rerankTopK: number;          // Re-rankear top N para precisiÃ³n
  
  // Query understanding
  queryExpansion: boolean;
  hydeGeneration: boolean;      // Hypothetical Document Embeddings
  
  // Contextual
  conversationHistory: boolean;
  userPreferences: boolean;
}

interface RetrievedContext {
  chunks: EnrichedChunk[];
  sources: SourceAttribution[];
  confidence: number;
  coverage: number;              // % de la query cubierto
  
  // Para debugging y UI
  retrievalPath: RetrievalStep[];
  timing: {
    queryUnderstanding: number;
    vectorSearch: number;
    reranking: number;
    total: number;
  };
}

export class AdvancedRetriever {
  private embedder: GeminiEmbedder;
  private vectorStore: MongoVectorStore;
  private reranker: CrossEncoderReranker;
  private queryEngine: QueryUnderstandingEngine;
  
  async retrieve(query: string, config: RetrievalConfig): Promise<RetrievedContext> {
    const startTime = performance.now();
    const retrievalPath: RetrievalStep[] = [];
    
    // â”€â”€â”€ FASE 1: QUERY UNDERSTANDING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const queryStart = performance.now();
    
    // 1.1 AnÃ¡lisis de intenciÃ³n
    const intent = await this.queryEngine.classifyIntent(query);
    retrievalPath.push({ step: 'intent_classification', result: intent });
    
    // 1.2 ExtracciÃ³n de entidades
    const entities = await this.queryEngine.extractEntities(query);
    retrievalPath.push({ step: 'entity_extraction', entities });
    
    // 1.3 ExpansiÃ³n de query (sinÃ³nimos, tÃ©rminos tÃ©cnicos)
    let expandedQuery = query;
    if (config.queryExpansion) {
      expandedQuery = await this.queryEngine.expand(query, entities);
      retrievalPath.push({ step: 'query_expansion', original: query, expanded: expandedQuery });
    }
    
    // 1.4 HyDE: Generar documento hipotÃ©tico ideal
    let queryEmbedding: number[];
    if (config.hydeGeneration && intent.requiresReasoning) {
      const hypotheticalDoc = await this.generateHypotheticalDocument(expandedQuery, intent);
      queryEmbedding = await this.embedder.embed(hypotheticalDoc);
      retrievalPath.push({ step: 'hyde', hypotheticalDoc: hypotheticalDoc.substring(0, 200) });
    } else {
      queryEmbedding = await this.embedder.embed(expandedQuery);
    }
    
    const queryTime = performance.now() - queryStart;
    
    // â”€â”€â”€ FASE 2: MULTI-STRATEGY RETRIEVAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const searchStart = performance.now();
    
    // 2.1 Dense retrieval (semantic)
    const semanticResults = await this.vectorStore.similaritySearch(queryEmbedding, {
      topK: config.topK * 2, // MÃ¡s candidatos para re-ranking
      filter: this.buildSecurityFilter(),
      minScore: 0.7,
    });
    
    // 2.2 Sparse retrieval (BM25 para tÃ©rminos especÃ­ficos)
    const sparseResults = await this.sparseSearch(expandedQuery, {
      topK: config.topK,
      boostTerms: entities.map(e => e.name), // Boost a entidades detectadas
    });
    
    // 2.3 Graph traversal (si hay entidades conectadas)
    let graphResults: Chunk[] = [];
    if (entities.length > 0 && this.hasKnowledgeGraph()) {
      graphResults = await this.graphTraverse(entities, 2); // 2-hop
    }
    
    // 2.4 Fusion de resultados (Reciprocal Rank Fusion)
    const fusedResults = this.reciprocalRankFusion(
      [semanticResults, sparseResults, graphResults],
      weights: [0.5, 0.3, 0.2]
    );
    
    const searchTime = performance.now() - searchStart;
    
    // â”€â”€â”€ FASE 3: RE-RANKING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const rerankStart = performance.now();
    
    // Re-rankear con cross-encoder (mÃ¡s preciso, mÃ¡s lento)
    const rerankedResults = await this.reranker.rerank(
      query,
      fusedResults.slice(0, config.rerankTopK),
      { strategy: 'cross_encoder' }
    );
    
    // DiversificaciÃ³n: evitar chunks muy similares
    const diversifiedResults = this.diversifyResults(rerankedResults, {
      maxSimilarity: 0.85,      // No incluir si > 85% similar
      ensureCoverage: true,     // Cubrir diferentes aspectos de la query
    });
    
    const rerankTime = performance.now() - rerankStart;
    
    // â”€â”€â”€ FASE 4: ENRIQUECIMIENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const enrichedChunks = await this.enrichChunks(diversifiedResults, {
      addParentContext: true,    // Incluir contexto del padre
      addSiblingSummary: true,   // Resumen de chunks relacionados
      resolveReferences: true,   // Resolver referencias cruzadas
    });
    
    // â”€â”€â”€ FASE 5: VERIFICACIÃ“N DE COBERTURA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const coverage = this.calculateCoverage(query, enrichedChunks);
    
    // Si cobertura baja, intentar query decomposition
    if (coverage.score < 0.7 && intent.isComplex) {
      const subQueries = await this.decomposeQuery(query);
      const subResults = await Promise.all(
        subQueries.map(sq => this.retrieve(sq, { ...config, hydeGeneration: false }))
      );
      // Merge de resultados de sub-queries
      return this.mergeSubQueryResults(subResults, coverage);
    }
    
    const totalTime = performance.now() - startTime;
    
    return {
      chunks: enrichedChunks.slice(0, config.topK),
      sources: this.extractSources(enrichedChunks),
      confidence: this.calculateConfidence(enrichedChunks, rerankedResults),
      coverage: coverage.score,
      retrievalPath,
      timing: {
        queryUnderstanding: queryTime,
        vectorSearch: searchTime,
        reranking: rerankTime,
        total: totalTime,
      },
    };
  }
  
  private async generateHypotheticalDocument(query: string, intent: Intent): Promise<string> {
    // HyDE: Generar el documento ideal que responderÃ­a la query
    const hydePrompt = `
      Genera un pÃ¡rrafo tÃ©cnico que responda directamente esta pregunta.
      El pÃ¡rrafo debe ser factual, especÃ­fico, y escrito como si fuera 
      parte de un manual tÃ©cnico o documentaciÃ³n.
      
      Pregunta: ${query}
      Tipo de respuesta esperada: ${intent.expectedAnswerType}
    `;
    
    // Usar modelo ligero para velocidad
    return await gemini.generate(hydePrompt, { 
      model: 'gemini-1.5-flash',
      temperature: 0.3,
      maxTokens: 200,
    });
  }
  
  private reciprocalRankFusion(
    resultSets: Chunk[][],
    weights: number[]
  ): ScoredChunk[] {
    const scores = new Map<string, number>();
    const chunks = new Map<string, Chunk>();
    
    resultSets.forEach((results, setIndex) => {
      results.forEach((chunk, rank) => {
        const rrfScore = weights[setIndex] * (1 / (rank + 60)); // k=60 constante
        scores.set(chunk.id, (scores.get(chunk.id) || 0) + rrfScore);
        chunks.set(chunk.id, chunk);
      });
    });
    
    return Array.from(scores.entries())
      .map(([id, score]) => ({ ...chunks.get(id)!, rrfScore: score }))
      .sort((a, b) => b.rrfScore - a.rrfScore);
  }
  
  private diversifyResults(results: ScoredChunk[], config: DiversifyConfig): ScoredChunk[] {
    const selected: ScoredChunk[] = [results[0]];
    const embeddings = results.map(r => r.embedding);
    
    for (let i = 1; i < results.length && selected.length < config.topK; i++) {
      // Calificar similitud con todos los seleccionados
      const maxSimilarity = Math.max(...selected.map(s => 
        cosineSimilarity(s.embedding, results[i].embedding)
      ));
      
      // Incluir si es suficientemente diferente
      if (maxSimilarity < config.maxSimilarity) {
        selected.push(results[i]);
      }
    }
    
    return selected;
  }
}
3.3 Knowledge Graph Integration
TypeScript
Copy
// Detectado: GraphExplorer, "entity relationships"

// lib/rag/graph/knowledge-graph-retriever.ts

interface GraphNode {
  id: string;
  type: 'document' | 'chunk' | 'entity' | 'concept';
  label: string;
  properties: Record<string, any>;
  embedding?: number[];
}

interface GraphEdge {
  source: string;
  target: string;
  type: 'contains' | 'references' | 'similar_to' | 'contradicts';
  weight: number;
  evidence: string;
}

export class KnowledgeGraphRAG {
  private graphStore: Neo4jStore | MongoGraphStore;
  
  async traverseFromEntities(
    entities: ExtractedEntity[],
    hops: number = 2
  ): Promise<GraphRetrievalResult> {
    const visited = new Set<string>();
    const frontier = entities.map(e => ({ id: e.id, hop: 0 }));
    const results: GraphNode[] = [];
    
    while (frontier.length > 0) {
      const current = frontier.shift()!;
      if (current.hop > hops || visited.has(current.id)) continue;
      
      visited.add(current.id);
      const node = await this.graphStore.getNode(current.id);
      results.push(node);
      
      // Expandir vecinos
      const neighbors = await this.graphStore.getNeighbors(current.id, {
        edgeTypes: ['references', 'similar_to'],
        minWeight: 0.7,
      });
      
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor.id)) {
          frontier.push({ id: neighbor.id, hop: current.hop + 1 });
        }
      }
    }
    
    // Encontrar chunks mÃ¡s relevantes en el subgrafo
    const chunkNodes = results.filter(n => n.type === 'chunk');
    const rankedByCentrality = this.rankByGraphCentrality(chunkNodes, visited);
    
    return {
      chunks: rankedByCentrality,
      subgraph: this.extractSubgraph(visited),
      paths: this.findExplanationPaths(entities, rankedByCentrality[0]),
    };
  }
  
  private rankByGraphCentrality(chunks: GraphNode[], relevantNodes: Set<string>): GraphNode[] {
    // PageRank personalizado: solo considerar nodos relevantes
    return chunks.map(chunk => ({
      ...chunk,
      centralityScore: this.calculatePersonalizedPageRank(chunk.id, relevantNodes),
    })).sort((a, b) => b.centralityScore - a.centralityScore);
  }
}
4. GENERATION - ANÃLISIS Y OPTIMIZACIÃ“N
4.1 Arquitectura de Generation Detectada
TypeScript
Copy
// Basado en: ConversationalSearch, SandboxChat, AgentTraceViewer
// y sistema de prompts detectado

// Componentes:
interface GenerationSystem {
  model: 'gemini-1.5-pro' | 'gemini-1.5-flash';
  
  // Prompt management (detectado en admin/prompts)
  promptEngine: {
    versioning: boolean;
    environments: ('STAGING' | 'PRODUCTION')[];
    multiTenant: boolean;
    variables: string[];
  };
  
  // Output control
  streaming: boolean;
  structuredOutput: boolean;     // JSON mode, detectado en schemas
  
  // Safety
  grounding: boolean;            // Google Search grounding?
  citations: boolean;              // AtribuciÃ³n de fuentes
}
ğŸ”´ Problemas CrÃ­ticos de Generation
Table
Copy
Problema	Severidad	Evidencia	SoluciÃ³n
Sin control de alucinaciones	CrÃ­tica	No detectado sistema de verificaciÃ³n	Implementar self-consistency + fact checking
Prompt injection vulnerable	Alta	Prompts dinÃ¡micos sin sanitizaciÃ³n	Input validation + delimiter strictness
No hay fallback de modelo	Media	Solo Gemini detectado	Circuit breaker con modelo secundario
Streaming sin manejo de errores	Media	UI de streaming visible	Reconnect logic + degradation
Falta citation exacta	Baja	"sources" mencionados pero no verificados	Span-level attribution
4.2 Sistema de Generation Robusto
TypeScript
Copy
// lib/rag/generation/rag-generator.ts

interface GenerationConfig {
  model: string;
  temperature: number;
  maxTokens: number;
  
  // Control de calidad
  selfConsistency: {
    enabled: boolean;
    samples: number;           // N respuestas para voting
    agreementThreshold: number;
  };
  
  factChecking: {
    enabled: boolean;
    method: 'retrieval' | 'llm_judge' | 'both';
  };
  
  safety: {
    grounding: boolean;
    citationRequired: boolean;
    maxHallucinationScore: number;
  };
}

interface RAGResponse {
  content: string;
  citations: Citation[];
  confidence: number;
  hallucinationRisk: 'low' | 'medium' | 'high';
  
  // Para debugging
  generationTrace: GenerationStep[];
  alternativeAnswers?: string[];  // Para self-consistency
  factCheckResults?: FactCheckResult[];
}

export class RAGGenerator {
  private model: GeminiModel;
  private retriever: AdvancedRetriever;
  private factChecker: FactChecker;
  
  async generate(query: string, context: RetrievedContext, config: GenerationConfig): Promise<RAGResponse> {
    const trace: GenerationStep[] = [];
    
    // â”€â”€â”€ FASE 1: CONSTRUCCIÃ“N DE PROMPT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const promptStart = performance.now();
    
    const systemPrompt = await this.loadPrompt('rag_system', {
      environment: 'production',
      tenantId: context.tenantId,
      industry: context.industry,
    });
    
    const contextString = this.formatContext(context.chunks, {
      includeCitations: true,
      maxLength: 4000,           // LÃ­mite de contexto
      prioritizeDiverse: true, // Asegurar cobertura de diferentes fuentes
    });
    
    const userPrompt = this.buildUserPrompt(query, contextString, {
      requireCitations: config.safety.citationRequired,
      answerFormat: this.determineFormat(query),
    });
    
    trace.push({ 
      step: 'prompt_construction', 
      contextTokens: this.estimateTokens(contextString),
      systemPromptLength: systemPrompt.length,
      duration: performance.now() - promptStart 
    });
    
    // â”€â”€â”€ FASE 2: GENERACIÃ“N CON SELF-CONSISTENCY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const generationStart = performance.now();
    
    let responses: string[];
    if (config.selfConsistency.enabled) {
      // Generar mÃºltiples respuestas con diferentes seeds
      responses = await Promise.all(
        Array(config.selfConsistency.samples).fill(0).map((_, i) =>
          this.model.generate({
            systemPrompt,
            userPrompt,
            temperature: 0.3 + (i * 0.1), // Variedad controlada
            maxTokens: config.maxTokens,
          })
        )
      );
      
      // Voting por consistencia
      const { consensus, agreement, alternatives } = this.consistencyVoting(responses);
      responses = [consensus];
      
      trace.push({
        step: 'self_consistency',
        samples: config.selfConsistency.samples,
        agreementScore: agreement,
        usedConsensus: agreement >= config.selfConsistency.agreementThreshold,
      });
    } else {
      const response = await this.model.generate({
        systemPrompt,
        userPrompt,
        temperature: config.temperature,
        maxTokens: config.maxTokens,
        streaming: true,           // Para UI responsiva
      });
      responses = [response];
    }
    
    const mainResponse = responses[0];
    
    trace.push({
      step: 'generation',
      duration: performance.now() - generationStart,
      outputTokens: this.estimateTokens(mainResponse),
    });
    
    // â”€â”€â”€ FASE 3: VERIFICACIÃ“N DE HECHOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let factCheckResults: FactCheckResult[] | undefined;
    if (config.factChecking.enabled) {
      const factCheckStart = performance.now();
      
      // Extraer claims verificables
      const claims = await this.extractClaims(mainResponse);
      
      // Verificar contra contexto recuperado
      factCheckResults = await this.factChecker.verify(claims, context.chunks);
      
      // Calcular riesgo de alucinaciÃ³n
      const hallucinationScore = this.calculateHallucinationRisk(factCheckResults);
      
      trace.push({
        step: 'fact_checking',
        claimsChecked: claims.length,
        verifiedClaims: factCheckResults.filter(r => r.verified).length,
        hallucinationScore,
        duration: performance.now() - factCheckStart,
      });
      
      // Si riesgo alto, regenerar con instrucciones mÃ¡s estrictas
      if (hallucinationScore > config.safety.maxHallucinationScore) {
        const conservativePrompt = this.buildConservativePrompt(query, context, factCheckResults);
        const conservativeResponse = await this.model.generate({
          systemPrompt: systemPrompt + '\n\n' + CONSERVATIVE_INSTRUCTIONS,
          userPrompt: conservativePrompt,
          temperature: 0.1,
        });
        
        responses = [conservativeResponse];
        trace.push({ step: 'conservative_regeneration', reason: 'high_hallucination_risk' });
      }
    }
    
    // â”€â”€â”€ FASE 4: EXTRACCIÃ“N DE CITACIONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const citations = this.extractCitations(mainResponse, context.chunks);
    
    // â”€â”€â”€ FASE 5: POST-PROCESAMIENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const finalResponse = this.postProcess(mainResponse, {
      removeUnverifiedClaims: config.factChecking.enabled,
      ensureCitations: config.safety.citationRequired,
      formatOutput: true,
    });
    
    return {
      content: finalResponse,
      citations,
      confidence: this.calculateOverallConfidence(context, factCheckResults, trace),
      hallucinationRisk: this.classifyRisk(factCheckResults),
      generationTrace: trace,
      alternativeAnswers: config.selfConsistency.enabled ? responses.slice(1) : undefined,
      factCheckResults,
    };
  }
  
  private formatContext(chunks: EnrichedChunk[], options: FormatOptions): string {
    return chunks.map((chunk, idx) => {
      let formatted = `[${idx + 1}] `;
      
      // Metadata de fuente
      if (chunk.context.title) {
        formatted += `**${chunk.context.title}** - `;
      }
      
      // Contenido con contexto
      formatted += chunk.content;
      
      // Contexto padre si es relevante
      if (options.includeParentContext && chunk.parentContext) {
        formatted += `\n   (Contexto: ${chunk.parentContext.summary})`;
      }
      
      return formatted;
    }).join('\n\n');
  }
  
  private consistencyVoting(responses: string[]): ConsistencyResult {
    // Usar embeddings para medir similitud semÃ¡ntica
    const embeddings = await Promise.all(
      responses.map(r => this.embedder.embed(r))
    );
    
    // Encontrar el "centroide" de respuestas
    const centroid = averageVectors(embeddings);
    
    // Calcular similitud de cada respuesta al centroide
    const similarities = embeddings.map(e => cosineSimilarity(e, centroid));
    
    // La respuesta mÃ¡s cercana al centroide es el consenso
    const consensusIndex = similarities.indexOf(Math.max(...similarities));
    
    // Calcular acuerdo (varianza de similitudes)
    const agreement = 1 - (standardDeviation(similarities) / mean(similarities));
    
    return {
      consensus: responses[consensusIndex],
      agreement,
      alternatives: responses.filter((_, i) => i !== consensusIndex),
    };
  }
  
  private async extractClaims(text: string): Promise<Claim[]> {
    // Usar LLM para extraer proposiciones verificables
    const extractionPrompt = `
      Extrae las afirmaciones factuales de este texto. Para cada una, indica:
      1. La afirmaciÃ³n exacta
      2. El tipo: nÃºmero, fecha, definiciÃ³n, procedimiento, causalidad
      3. Si requiere verificaciÃ³n externa
      
      Texto: ${text}
      
      Responde en JSON: {"claims": [{"text": "...", "type": "...", "requiresVerification": true/false}]}
    `;
    
    const result = await this.model.generate(extractionPrompt, {
      responseFormat: 'json',
      temperature: 0,
    });
    
    return JSON.parse(result).claims;
  }
}
4.3 Streaming con Resiliencia
TypeScript
Copy
// lib/rag/generation/streaming-generator.ts

interface StreamingConfig {
  onChunk: (chunk: string, metadata: ChunkMetadata) => void;
  onCitation: (citation: Citation) => void