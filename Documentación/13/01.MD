# Auditoría Técnica Profunda: Arquitectura Core del Sistema

## Resumen Ejecutivo

Este documento analiza los tres pilares arquitectónicos de la plataforma ABD RAG: el **Entity Engine** (sistema de abstracción de datos), el **Motor de Workflows** (orquestación de procesos técnicos) y la **Arquitectura RAG** (sistema de recuperación de conocimiento). Se incluyen fragmentos de código extraídos del codebase, análisis de fortalezas/weaknesses y hoja de ruta técnica.

---

## 1. Entity Engine: El "Cerebro" de Abstracción de Datos

### 1.1 Concepto Arquitectónico

El Entity Engine es un **sistema de metaprogramación declarativa** que permite definir estructuras de datos complejas (entidades) mediante configuración JSON/YAML en lugar de código TypeScript estático. Esto habilita el multi-tenancy vertical donde cada tenant puede tener campos personalizados sin modificar el core.

**Flujo de Datos:**
Ontología (Entity Definition)
↓
EntityEngine.getInstance().getEntity('pedido')
↓
Generación dinámica de:
API Routes (/api/core/entities/[type])
Formularios (DynamicFormModal)
Tablas (DataTable con columnas generadas)
Validaciones (Zod schemas dinámicos)
Cifrado de campos sensibles (SecurityService)
Copy

### 1.2 Implementación Observada

**Definición de Entidad (Ontología):**
```typescript
// Ejemplo inferido del uso en entities/page.tsx
const entity = EntityEngine.getInstance().getEntity('pedido');

// Estructura esperada de entity:
{
  slug: 'pedido',
  name: 'Pedido Técnico',
  plural: 'Pedidos',
  api: {
    list: '/api/core/entities/pedido',
    detail: '/api/core/entities/pedido/:id',
    analyze: '/api/core/entities/pedido/analyze'
  },
  fields: [
    { key: 'identifier', type: 'string', required: true, searchable: true },
    { key: 'client', type: 'string', encrypted: false },
    { key: 'technicalSpecs', type: 'json', encrypted: true }, // Campo sensible
    { key: 'status', type: 'enum', options: ['draft', 'analyzed', 'validated'] }
  ]
}
Consumo en Frontend:
TypeScript
Copy
// src/app/(authenticated)/(technical)/entities/page.tsx
const entity = EntityEngine.getInstance().getEntity('pedido')!;

// Hook genérico que adapta automáticamente al endpoint de la entidad
const { data: entities, refresh } = useApiList<any>({
  endpoint: entity.api.list,
  dataKey: 'entities',
  filters: { limit: 5 }
});

// Mutación adaptativa
const handleAnalysis = async () => {
  const resp = await fetch(entity.api.analyze!, { ... });
  // La respuesta se normaliza automáticamente sin importar el tipo de entidad
};
Backend - API Universal:
TypeScript
Copy
// src/app/api/core/entities/[type]/route.ts
export async function GET(req: NextRequest, { params }: { params: Promise<{ type: string }> }) {
  const { type } = await params;
  const entityDef = EntityEngine.getInstance().getEntity(type);
  
  if (!entityDef) throw new AppError('NOT_FOUND', 404, `Entidad '${type}' no reconocida`);

  const collection = await getTenantCollection(entityDef.slug);
  
  // Construcción dinámica de filtros basada en campos "searchable"
  const filter: any = {};
  if (search) {
    const searchableFields = entityDef.fields.filter(f => f.searchable).map(f => f.key);
    filter.$or = searchableFields.map(f => ({
      [f]: { $regex: search, $options: 'i' }
    }));
  }
  
  return NextResponse.json({
    success: true,
    [entityDef.plural]: items, // Clave dinámica (pedidos, equipos, etc.)
    pagination: { total, page, limit }
  });
}
1.3 Seguridad: Cifrado Selectivo
TypeScript
Copy
// src/app/api/core/entities/[type]/[id]/route.ts
// Descifrado en lectura
entityDef.fields.forEach(field => {
  if (SecurityService.shouldEncryptField(field.key) && entity[field.key]) {
    entity[field.key] = SecurityService.decrypt(entity[field.key]);
  }
});

// Cifrado en escritura (PATCH)
entityDef.fields.forEach(field => {
  if (SecurityService.shouldEncryptField(field.key) && body[field.key]) {
    body[field.key] = SecurityService.encrypt(body[field.key]);
  }
});
1.4 Fortalezas Identificadas
DRY extremo: Un solo componente DynamicFormModal sirve para crear/editar cualquier entidad sin repetir código JSX
Multi-tenancy real: Cada tenant puede tener configuraciones de entidad diferentes (ej: Pedidos para ascensores vs Pedidos para equipos médicos)
Seguridad granular: Cifrado a nivel de campo, no de tabla completa
Type Safety: Aunque usa any en algunos hooks, la estructura permite generación automática de tipos desde la ontología
1.5 Debilidades Críticas & Mejoras
Problema 1: N+1 Queries en Relaciones
El código actual no implementa "eager loading". Si una entidad pedido referencia a cliente, se hacen 2 queries.
Solución recomendada:
TypeScript
Copy
// Agregar a la definición de entidad
relations: [
  { 
    field: 'clientId', 
    target: 'cliente', 
    type: 'many-to-one',
    eager: true // Carga automática en GET
  }
]

// Implementar aggregation con $lookup en MongoDB
const pipeline = [
  { $match: filter },
  { $lookup: {
      from: 'clientes',
      localField: 'clientId',
      foreignField: '_id',
      as: 'clientData'
  }}
];
Problema 2: Validación Zod Dinámica
Actualmente se valida contra schemas estáticos. Para campos dinámicos de tenant, se necesita:
TypeScript
Copy
// Generación runtime de Zod schemas
const generateZodSchema = (fields: EntityField[]) => {
  const shape: Record<string, z.ZodTypeAny> = {};
  fields.forEach(field => {
    switch(field.type) {
      case 'string': shape[field.key] = z.string().min(1); break;
      case 'email': shape[field.key] = z.string().email(); break;
      case 'encrypted': shape[field.key] = z.string().max(1000); break;
    }
  });
  return z.object(shape);
};
Problema 3: Índices MongoDB Dinámicos
Los campos searchable requieren índices de texto, pero no hay garantía de que existan.
Recomendación: Implementar un "Migration Runner" que verifique/created índices al iniciar:
TypeScript
Copy
// En el startup del servidor
fields.filter(f => f.searchable).forEach(field => {
  collection.createIndex({ [field.key]: 'text' });
});
2. Sistema de Workflows: Orquestación de Procesos Técnicos
2.1 Concepto Arquitectónico
Sistema FSM (Finite State Machine) multinivel que gestiona el ciclo de vida de entidades con reglas de negocio complejas:
Estados personalizables por tenant (ej: "Ingresado" → "Análisis IA" → "Validación Técnica" → "Aprobado")
Transiciones condicionadas por roles (solo ADMIN puede pasar a "Aprobado")
Firmas digitales y trazabilidad completa (quién, cuándo, por qué)
2.2 Implementación Observada
Definición de Workflow:
TypeScript
Copy
// src/app/api/admin/workflow-definitions/route.ts
interface WorkflowDefinition {
  entityType: 'ENTITY' | 'EQUIPMENT' | 'USER';
  states: Array<{
    id: string;
    label: string;
    color: string;
    is_initial: boolean;
    is_final: boolean;
  }>;
  transitions: Array<{
    from: string;
    to: string;
    allowedRoles: string[];
    requiresSignature: boolean;
    requiresComment: boolean;
  }>;
  initial_state: string;
}
Ejecución de Transición:
TypeScript
Copy
// src/app/api/cases/[id]/transition/route.ts
export async function POST(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const { toState, comment, signature } = body;
  
  const result = await WorkflowEngine.executeTransition({
    caseId: id,
    toState,
    role: session.user.role,
    correlationId: correlacion_id,
    comment,
    signature // Firma digital capturada
  });
  
  // Auditoría automática
  await logEvento({
    level: 'INFO',
    source: 'WORKFLOW',
    action: 'STATE_TRANSITION',
    details: { from: currentState, to: toState, user: session.user.email }
  });
}
Visualización en UI:
TypeScript
Copy
// src/app/(authenticated)/(admin)/admin/workflows/page.tsx
<WorkflowStatusBar 
  states={definition.states}
  currentStateId={definition.initial_state}
  transitions_history={[]}
/>
2.3 Patrones Avanzados Detectados
1. Validación de Permisos en Transición:
El motor verifica no solo el rol, sino que el usuario tenga acceso al tenant específico:
TypeScript
Copy
// Inferido de WorkflowEngine.executeTransition
if (session.user.role !== 'SUPER_ADMIN') {
  const case = await collection.findOne({ _id: id });
  if (case.tenantId !== session.user.tenantId) {
    throw new AppError('FORBIDDEN', 403, 'Cross-tenant workflow access denied');
  }
}
2. Hooks de Negocio:
El workflow permite ejecutar lógica custom al entrar/salir de estados (similar a AWS Step Functions):
Al entrar a "Análisis IA": Trigger automático del AgentEngine
Al salir de "Validación": Generar PDF de certificación
2.4 Fortalezas Identificadas
Compliance total: Toda transición es inmutable (append-only log)
Flexibilidad: Los estados son configurables por tenant sin deploy
Integridad: Uso de firmas digitales (campo signature) para validaciones críticas
2.5 Debilidades Críticas & Mejoras
Problema 1: Race Conditions
Dos técnicos pueden intentar transicionar el mismo caso simultáneamente.
Solución: Optimistic Locking
TypeScript
Copy
// Agregar campo version a los casos
const result = await collection.updateOne(
  { 
    _id: caseId, 
    currentState: fromState, // Solo actualizar si sigue en el estado esperado
    version: expectedVersion 
  },
  { 
    $set: { currentState: toState, version: expectedVersion + 1 },
    $push: { history: newTransition }
  }
);

if (result.modifiedCount === 0) {
  throw new AppError('CONFLICT', 409, 'El caso fue modificado por otro usuario');
}
Problema 2: Escalabilidad de Historial
El array transitions_history puede crecer indefinidamente (anti-pattern en MongoDB).
Solución: Archivado
TypeScript
Copy
// Separar historia activa vs archivada
// Colección cases: solo últimas 10 transiciones
// Colección case_history_archive: resto
// Índice TTL para borrar historial antiguo (>2 años)
Problema 3: Validación de Reglas de Negocio Complejas
Actualmente solo valida roles. Falta validar condiciones basadas en datos:
TypeScript
Copy
// Ejemplo: No permitir aprobar si el monto > $10k sin supervisor
transitions: [{
  from: 'review',
  to: 'approved',
  condition: {
    field: 'amount',
    operator: 'lessThan',
    value: 10000
  },
  alternativeState: 'pending_supervisor' // Si falla la condición, va aquí
}]
3. Arquitectura RAG: Sistema de Conocimiento Vectorial
3.1 Concepto Arquitectónico
Implementación RAG Híbrida (Lexical + Vectorial) con las siguientes capas:
Ingesta: Procesamiento de PDFs con chunking inteligente
Embeddings: Generación de vectores (probablemente OpenAI o similar)
Almacenamiento: MongoDB con índices vectoriales (Atlas Vector Search)
Recuperación: Búsqueda semántica + filtrado por metadata (tenant, estado)
Generación: Augmentación de prompts con contexto recuperado
3.2 Implementación Observada
Pipeline de Ingesta:
TypeScript
Copy
// src/app/api/admin/ingest/route.ts
export async function POST(req: NextRequest) {
  const formData = await req.formData();
  const file = formData.get('file') as File;
  
  // Delegación a servicio especializado
  const result = await IngestService.processDocument({
    file,
    metadata: { type, version },
    tenantId,
    userEmail,
    correlationId
  });
  
  // Creación de chunks vectoriales
  // (Implicito en el código, no se ve la implementación pero se inferen los esquemas)
}
Búsqueda Híbrida:
TypeScript
Copy
// src/app/api/admin/knowledge-base/chunks/route.ts
if (searchType === 'semantic' && query) {
  const { hybridSearch } = await import('@/lib/rag-service');
  chunks = await hybridSearch(
    query, 
    session?.user?.tenantId || 'global', 
    correlationId, 
    limit
  );
} else {
  // Fallback a regex (búsqueda lexical)
  filter.$or = [
    { chunkText: { $regex: query, $options: 'i' } },
    { model: { $regex: query, $options: 'i' } }
  ];
}
Evaluación de Calidad (RAGAs):
TypeScript
Copy
// src/app/api/admin/rag/evaluations/route.ts
const evals = await collection.find({ tenantId })
  .sort({ timestamp: -1 })
  .limit(50)
  .toArray();

// Métricas calculadas:
// - faithfulness (alucinación)
// - answer_relevance 
// - context_precision
const stats = {
  faithfulness: evals.reduce((acc, curr) => acc + curr.metrics.faithfulness, 0) / evals.length
};
3.3 Gestión del Ciclo de Vida de Documentos
TypeScript
Copy
// src/app/api/admin/knowledge-assets/status/route.ts
// Actualización atómica de documento + chunks (Transacción MongoDB)
await session_db.withTransaction(async () => {
  await db.collection('knowledge_assets').updateOne(
    { _id: new ObjectId(documentId) },
    { $set: { status: newStatus } }
  );
  
  await db.collection('document_chunks').updateMany(
    { cloudinary_public_id: publicId },
    { $set: { status: newStatus } }
  );
});
3.4 Fortalezas Identificadas
Multi-tenant seguro: Los chunks incluyen tenantId en el filtrado
Calidad monitoreada: Sistema de evaluación continua con RAGAs
Soft-delete compliance: Los documentos no se borran físicamente, se marcan como 'obsoleto'
Shadow chunks: Soporte para chunks "fantasma" (probablemente para testing A/B de chunking strategies)
3.5 Debilidades Críticas & Mejoras
Problema 1: No hay Re-ranking
La búsqueda híbrida retorna resultados por similitud coseno, pero no re-ranking por relevancia semántica profunda.
Implementación recomendada:
TypeScript
Copy
// Agregar capa de Cross-Encoder (Cohere o similar)
const retrieve = async (query: string) => {
  // 1. Recuperar top-k (k=20) con vector search
  const candidates = await vectorSearch(query, 20);
  
  // 2. Re-rank con modelo de mayor precisión
  const scored = await cohere.rerank({
    query,
    documents: candidates.map(c => c.chunkText),
    topN: 5
  });
  
  return scored.map(s => candidates[s.index]);
};
Problema 2: Chunking Naive
No se observa chunking por "semantic boundaries" (párrafos) o "sliding window".
Mejora:
TypeScript
Copy
// Estrategia de chunking híbrida
const chunkDocument = (pdfText: string) => {
  // 1. Dividir por headers (h1, h2) primero
  const sections = splitByHeaders(pdfText);
  
  // 2. Si una sección es muy larga, aplicar sliding window
  return sections.flatMap(section => 
    section.length > 1000 
      ? slidingWindow(section, size=800, overlap=100)
      : [section]
  );
};
Problema 3: Falta de "Query Transformation"
Las queries de usuarios técnicos pueden ser ambiguas ("problema con el motor").
Implementar:
TypeScript
Copy
// Query expansion con LLM
const expandQuery = async (userQuery: string) => {
  const prompt = `Genera 3 reformulaciones técnicas de: "${userQuery}"`;
  const variations = await gemini.generate(prompt);
  return [userQuery, ...variations];
};

// Búsqueda multi-query
const results = await Promise.all(
  expandedQueries.map(q => hybridSearch(q, tenantId, limit=3))
);
// Fusionar resultados (RRF - Reciprocal Rank Fusion)
Problema 4: Costos de Embeddings
Regenerar embeddings para todo el corpus cuando cambia el modelo es costoso.
Solución: Versionado de Embeddings
TypeScript
Copy
// Esquema de chunks extendido
{
  chunkText: "...",
  embeddings: {
    "text-embedding-3-small": [0.1, 0.2, ...],
    "text-embedding-ada-002": [0.3, 0.4, ...] // Mantener versión anterior
  },
  embeddingVersion: "text-embedding-3-small"
}
4. Matriz de Interacción entre Sistemas
Copy
┌─────────────────────────────────────────────────────────────┐
│                         FLUJO TÍPICO                        │
└─────────────────────────────────────────────────────────────┘

1. INGESTA RAG
   PDF Técnico → IngestService → Chunks Vectoriales (MongoDB)
                                       ↓
2. ENTITY ENGINE                      ↓
   Técnico crea Pedido → DynamicForm → API Universal → MongoDB
                                       ↓
3. WORKFLOW TRIGGER                   ↓
   Estado: "Ingresado" → "Análisis IA" ───────┐
                                               ↓
4. RAG RETRIEVAL                    (Automático)
   Agent consulta: "¿Qué manuales aplican?" → hybridSearch
                                               ↓
5. VALIDACIÓN HUMANA                  ↓
   Técnico revisa → Workflow Transition → Firma Digital
                                               ↓
6. AUDITORÍA                          ↓
   Log inmutable → application_logs (compliance)
5. Recomendaciones Estratégicas de Implementación
Prioridad 1: Estabilidad (Semanas 1-2)
Implementar Optimistic Locking en WorkflowEngine para prevenir race conditions
Agregar Rate Limiting en /api/admin/ingest (procesamiento de PDFs es costoso)
Crear índices TTL en document_chunks para archivar chunks de documentos obsoletos (>1 año)
Prioridad 2: Performance (Semanas 3-4)
Mover Ingesta a Queue: Usar BullMQ o Inngest para procesamiento asíncrono de PDFs pesados
Implementar Edge Caching: Cachear definiciones de Entity y Workflow en Vercel Edge (cambian poco)
Query Transformation: Implementar expansión de queries en RAG para mejorar recall
Prioridad 3: Escalabilidad (Mes 2)
Shard de Colecciones: Preparar sharding por tenantId en MongoDB Atlas para >100k documentos
Reranking: Integrar Cohere Rerank o similar para mejorar precision@5
Entity Relations: Implementar eager loading con $lookup agregaciones para evitar N+1
Prioridad 4: Inteligencia (Mes 3)
Fine-tuning: Entrenar modelo ligero (Gemini 1.5 Flash fine-tuned) con datos técnicos específicos del tenant
Auto-classification: Usar Entity Engine para que la IA sugiera automáticamente el tipo de documento al subir PDFs
Predictive Workflows: ML para predecir cuánto tiempo pasará un caso en cada estado y alertar si hay riesgo de SLA breach
Conclusión
La arquitectura presenta un diseño enterprise maduro con separación clara de responsabilidades. El Entity Engine es particularmente elegente para manejar multi-tenancy vertical.
Los principales riesgos técnicos actuales son:
Race conditions en workflows concurrentes (falta de locking)
Escalabilidad del RAG sin re-ranking ni query expansion
Deuda de índices (falta de garantía de índices MongoDB para campos dinámicos)
Con las mejoras sugeridas, el sistema puede escalar a millones de documentos vectoriales y miles de tenants sin refactorización mayor, manteniendo la trazabilidad y compliance que requiere el sector industrial.
Nota final: Considerar la migración progresiva a LangChain/LangGraph para la orquestación de agentes RAG, manteniendo el Entity Engine como capa de abstracción de datos.