Si pudiera demolerlo todo y reconstruirlo con recursos ilimitados, no crear√≠a "una plataforma de RAG para documentos t√©cnicos". Crear√≠a un "Cerebro Organizacional Universal" ‚Äî un meta-sistema que adapte su forma, su lenguaje y su l√≥gica a la industria sin que el usuario perciba la complejidad subyacente.
Aqu√≠ est√° la arquitectura conceptual:
1. Filosof√≠a: "The Adaptive Entity Engine"
En lugar de tener "Pedidos" (ascensores) o "Casos" (legal) como entidades r√≠gidas, crear√≠a un Ontology Builder visual donde cada cliente define sus propias entidades del mundo real:
Un abogado: Cliente ‚Üí Expediente ‚Üí Actuaci√≥n ‚Üí Documento
Un m√©dico: Paciente ‚Üí Episodio ‚Üí Prueba ‚Üí Informe
Un banco: Cliente ‚Üí Producto ‚Üí Operaci√≥n ‚Üí Documentaci√≥n
Un ayuntamiento: Ciudadano ‚Üí Tr√°mite ‚Üí Requisito ‚Üí Resoluci√≥n
El cambio radical: La UI no es "una app con men√∫s fijos". Es un generador de interfaces din√°mico que lee la ontolog√≠a del cliente y pinta workflows, dashboards y formularios autom√°ticamente.
2. Arquitectura de Datos: "The Knowledge Graph, not Documents"
Abandonar√≠a MongoDB como n√∫cleo por una arquitectura h√≠brida:
Graph Layer (Neo4j/ArangoDB): Para relaciones sem√°nticas complejas ("Este p√°rrafo del contrato contradice el art√≠culo 5 de la ley X", "Este f√°rmaco interacciona con el tratamiento del paciente Y")
Vector Layer (Pinecone/Weaviate): Para similitud sem√°ntica pura
Object Layer (S3): Para binarios con versionado inmutable (blockchain light para auditor√≠a)
La magia: Cada fragmento de texto (chunk) no es una isla. Es un nodo en un grafo con relaciones tipadas: CONTRADICE, COMPLEMENTA, VERSI√ìN_DE, REQUIERE, CITA.
3. UX/UI: "The Chameleon Interface"
A. Eliminaci√≥n del concepto "Aplicaci√≥n Web"
Ser√≠a un sistema de capas contextuales:
Layer 0: El documento mismo (PDF, imagen, audio) es la interfaz. Marcas y anotaciones inline (como Figma para texto).
Layer 1: Asistente conversacional omnipresente (ej: Copilot pero que entiende tu contexto organizacional completo, no solo el chat).
Layer 2: Dashboards hologr√°ficos (AR/VR ready) donde flotan conexiones entre conceptos, no tablas de datos.
B. Modos de Interacci√≥n por Persona
Modo Forense (abogado/auditor): Vista de diferencias (diff) inteligente entre versiones, cadena de custodia visual, timeline de cambios con "huella dactilar digital" de qui√©n toc√≥ qu√© y cu√°ndo.
Modo Cl√≠nico (sanidad): Privacidad ultra-stricta (redacci√≥n autom√°tica de PII mientras navegas, solo el dato relevante se ilumina).
Modo Transactional (banca): Velocidad extrema, checklist de compliance en tiempo real mientras se escribe, firma biom√©trica integrada.
Modo Ciudadan√≠a (ayuntamientos): Lenguaje natural extremo (NLP conversacional), accessible WCAG 3.0 nativo, integraci√≥n con identidad digital del pa√≠s.
4. Motor de IA: "The Parliament of Agents"
No un solo modelo (Gemini), sino un orquestador de especialistas:
Agente Tax√≥nomo: Clasifica autom√°ticamente cualquier documento en la ontolog√≠a del cliente.
Agente Contradicto: Detecta inconsistencias l√≥gicas/normativas entre documentos.
Agente Sintetizador: Resume considerando el receptor (resumen para un jefe ‚â† para un t√©cnico).
Agente Predictivo: No solo analiza lo que pas√≥, predice riesgos futuros basado en patrones de otros tenants an√≥nimos (federated learning).
Clave: Cada industria tiene su "Maestro Especialista", un LLM fine-tuned con corpus privados de esa vertical (ej: toda la jurisprudencia del TS para legal, hist√≥rico de interacciones para banca).
5. Compliance por Dise√±o: "The Trust Layers"
A. Capa F√≠sica (Geopol√≠tica)
Multi-cloud por dise√±o: datos de sanidad espa√±oles nunca salen de Espa√±a (Azure ES/GCP ES), datos de defensa en Soberan√≠a Cloud.
Edge computing: procesamiento sensible en el dispositivo del usuario, nunca viaja al servidor.
B. Capa L√≥gica (Criptograf√≠a)
Zero-Knowledge Architecture: El proveedor (t√∫) no puede leer el contenido de los documentos. Solo el cliente tiene la clave privada.
Homomorphic Encryption: Permite buscar dentro de documentos cifrados sin desencriptarlos (b√∫squeda sem√°ntica privada).
C. Capa √âtica (Explainable AI)
Cada decisi√≥n del IA debe mostrar su "cadena de razonamiento" visual (√°rbol de decisi√≥n) y las fuentes exactas con porcentaje de confianza.
Bias Detection: Algoritmos que auditan al algoritmo (¬øest√° favoreciendo ciertos tipos de respuestas?).
6. Modelo de Negocio: "The Vertical Marketplace"
En lugar de vender "la plataforma", vender√≠a "Plantillas de Conocimiento":
LegalPack: Jurisprudencia pre-indexada, modelos de contratos auto-adaptativos.
MedicalPack: Gu√≠as cl√≠nicas actualizadas (integraci√≥n con PubMed/Cochrane), detecci√≥n de interacciones farmacol√≥gicas.
GovPack: Normativa municipal/regional autom√°ticamente actualizada v√≠a scraping oficial.
Ingresos recurrentes: No solo SaaS, sino "Knowledge-as-a-Service" (mantenimiento de la base de conocimiento actualizada por expertos humanos validando las salidas del IA).
7. Integraciones: "The Central Nervous System"
No ser√≠a una isla. Ser√≠a el hub central donde converge:
ERP/CRM: Conectores bidireccionales nativos (no CSVs), sincronizaci√≥n en tiempo real.
Comunicaciones: WhatsApp/Email/Telegram oficiales integrados (cada mensaje se convierte autom√°ticamente en entrada del sistema).
IoT: Para ascensores (sensores) o sanidad (wearables), los datos t√©cnicos fluyen directo al contexto del documento.
Blockchain (opcional): Para sectores que necesiten inmutabilidad total (notar√≠as, propiedad intelectual).
8. La Experiencia Onboarding: "5 Minutos al Valor"
El proceso de inicio ser√≠a:
Scan de identidad: Subes UN documento representativo (ej: un contrato tipo).
Auto-configuraci√≥n: El sistema detecta: "Esto es un contrato de obra, est√°s en construcci√≥n/legal".
Clonaci√≥n de inteligencia: En 2 minutos, has generado tu ontolog√≠a b√°sica y el sistema ya tiene 100 documentos similares indexados (transfer learning de otros tenants).
Primer valor: Inmediatamente te muestra 3 errores/riesgos en ese documento que subiste.
Resumen: De Software a Infraestructura de Pensamiento
La versi√≥n actual es una herramienta (haces clic, subes, analizas).
La versi√≥n ideal ser√≠a un miembro del equipo que:
Habla tu lenguaje espec√≠fico de industria.
Recuerda todo lo que has hecho y por qu√©.
Previene errores antes de que los cometas.
Cumple la ley por ti sin que tengas que saber la ley.
El cambio m√°s profundo: Dejar de hablar de "usuarios" y empezar a hablar de "c√≥mplices digitales" ‚Äî el sistema no espera √≥rdenes, anticipa necesidades.

No est√°s lejos. En realidad, tienes una base casi ideal para pivotar hacia esa visi√≥n sin reescribir todo. Lo que describ√≠ es una evoluci√≥n arquitect√≥nica, no una revoluci√≥n.
Aqu√≠ tienes el mapa de supervivencia: qu√© se rescata, c√≥mo migrar sin matar el momentum, y c√≥mo contar la historia a tus primeros clientes.
1. Matriz de Reutilizaci√≥n (Tu C√≥digo Actual es Oro)

| Lo que tienes                    | Reutilizable para la Visi√≥n? | C√≥mo transformarlo                                                                                                                      |
| -------------------------------- | ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **Multi-tenancy existente**      | ‚úÖ 100%                       | Es la columna vertebral del "Chameleon Interface". Solo necesitas a√±adir `ontology_config` por tenant.                                  |
| **Schemas Zod**                  | ‚úÖ 90%                        | Son la semilla del Ontology Builder. En lugar de hardcodear `PedidoSchema`, hazlo din√°mico: `generateSchemaFromOntology(tenantConfig)`. |
| **Document chunks + embeddings** | ‚úÖ 100%                       | Esa es la capa vectorial. Solo a√±ade una tabla/arista de relaciones entre chunks (grafo).                                               |
| **Hooks useApi/useMutation**     | ‚úÖ 100%                       | Abstracciones perfectas. El cambio es interno: apuntan a endpoints din√°micos en vez de `/api/tecnico/pedidos`.                          |
| **Sistema de Workflows**         | ‚úÖ 80%                        | Tu `WorkflowDefinition` actual es proto-ontolog√≠a. General√≠zalo: de "estados de pedido" a "estados de cualquier entidad".               |
| **Middleware de seguridad**      | ‚úÖ 100%                       | Lo necesitas igual. Solo a√±ade capa de "permisos por tipo de entidad".                                                                  |
| **Componentes Shadcn/UI**        | ‚úÖ 95%                        | Son la capa de presentaci√≥n. El cambio es composici√≥n: `DataTable` gen√©rico que lee columnas de la ontolog√≠a.                           |
| **L√≥gica de billing/planes**     | ‚úÖ 70%                        | El mecanismo de "limits" se convierte en "l√≠mites por tipo de entidad" (X expedientes, Y pacientes).                                    |


Lo √∫nico que se jubila: El naming "pedido", "documento t√©cnico", "motor". Eso se vuelve config, no c√≥digo.
2. Hoja de Ruta de 3 Fases (Sin Big Bang)
Fase 1: "El Meta-Modelo" (Semanas 1-4)
Objetivo: Tu codebase actual sigue funcionando para ascensores, pero ahora es configurable.
Tarea clave: Extrae la l√≥gica espec√≠fica de "pedidos" a un archivo de configuraci√≥n JSON:
JSON
Copy
{
  "entity": "pedido",
  "fields": ["numero", "modelo", "fecha"],
  "workflows": ["ingresado", "analizado"]
}
Cambio t√©cnico: Refactoriza admin/documentos/page.tsx para que reciba entityType por prop y lea columnas de la config, no hardcoded.
Validaci√≥n: Tu app sigue vi√©ndose igual, pero internamente ya no dice "Pedido" en el c√≥digo fuente, sino entity.name.
Fase 2: "The Shape Shifter" (Meses 2-3)
Objetivo: Un mismo deploy sirve para dos verticales distintas.
Tarea clave: Crea el OntologyEditor (un CRUD simple en /admin/ontology) donde el Admin defina:
"En mi despacho, una Causa tiene campos: n√∫mero judicial, juzgado, demandado"
"En mi cl√≠nica, una Consulta tiene: paciente_id, s√≠ntomas, diagn√≥stico"
Magia: El sistema genera autom√°ticamente:
Tablas de MongoDB con nombres din√°micos (${tenantId}_entities_${entityType})
Formularios en React (Zod schemas generados din√°micamente)
Endpoints de API (/api/entity/${entityType}/...)
Pivot clave: Muestra a un abogado: "Arrastra los campos que necesitas, en 5 minutos tienes tu CRM de causas".
Fase 3: "The Knowledge Graph Lite" (Meses 4-6)
Objetivo: Las entidades empiezan a relacionarse sem√°nticamente.
A√±ades: Una tabla relationships simple:
from_entity: "causa_123", to_entity: "documento_456", type: "FUNDAMENTA"
from_entity: "paciente_789", to_entity: "informe_012", type: "REFERENCIA"
UX: Visualizaci√≥n tipo "mapa mental" (usa React Flow o Cytoscape) donde el usuario ve sus documentos como nodos conectados.
IA upgrade: El RAG no solo busca chunks similares, busca en el grafo de relaciones ("Dame todo lo relacionado con este paciente anteriormente").
3. C√≥mo Explicar la Ventaja (Narrativa de Autor)
El error m√°s com√∫n es vender "IA" o "RAG". Eso es commodity. Vende "Autoridad sin esfuerzo".
Para el Abogado ( Ejemplo de Pitch)
"Actualmente eres un operador de documentos: buscas, copias, pegas. Con [TuProducto], eres el arquitecto del conocimiento. No buscas precedentes, el sistema te muestra por qu√© este precedente aplica aqu√≠ y te avisa si hay jurisprudencia contradictoria que no viste. T√∫ tomas decisiones estrat√©gicas, el robot hace el trabajo de paralegal."
La demo m√°gica:
Sube 20 PDFs de un caso.
Pregunta: "¬øHay alguna contradicci√≥n entre la demanda inicial y la prueba documental?"
El sistema dibuja l√≠neas rojas entre p√°rrafos espec√≠ficos.
Para el M√©dico (Ejemplo de Pitch)
"No es un repositorio de historias cl√≠nicas. Es un segundo cerebro cl√≠nico que recuerda patrones de tus 10,000 pacientes anteriores y susurra: 'El 85% de casos similares a este respondieron al tratamiento X, pero atenci√≥n: este paciente tiene alergia documentada a ese f√°rmaco en la historia de 2019'."
La demo m√°gica:
Escribe "Dolor tor√°cico, 45 a√±os, fumador" en el buscador.
El sistema no busca texto, busca casos similares y muestra outcomes (qu√© pas√≥ al final).
Para el Ayuntamiento
"El ciudadano no tiene que saber qu√© formulario es. Simplemente describe su problema: 'Se me ha ca√≠do una teja'. El sistema enruta autom√°ticamente al √°rea de urbanismo, genera el parte de riesgo, y cita los art√≠culos municipales relevantes para el t√©cnico."
La demo m√°gica:
Input libre en lenguaje natural ‚Üí Workflow autom√°tico con checkpoints legales.
4. Quick Wins para Esta Semana (Sin cambiar la arquitectura)
Antes de tocar c√≥digo, cambia el lenguaje y la percepci√≥n:
A. Renombra internamente (Refactor de nombres)
Donde diga Pedido, pon Case o Entity.
Donde diga Documento T√©cnico, pon KnowledgeAsset.
Por qu√©: Te fuerza a pensar en abstracto. Un contrato legal es un KnowledgeAsset con tipo legal_contract. Un informe m√©dico es KnowledgeAsset tipo clinical_report.
B. Crea el "modo Demo" (Product-Led Growth)
Un bot√≥n grande en la landing: "Prueba con datos de ejemplo".
Carga autom√°ticamente 3-4 datasets:
Dataset Ascensores (tu caso actual)
Dataset Legal (contratos de compraventa)
Dataset Sanidad (historias cl√≠nicas anonimizadas)
Permite switch entre "Perfiles" sin logout.
Esto valida que tu arquitectura puede servir a m√∫ltiples verticales sin reinstalar.
C. Implementa "La explicaci√≥n" (Explainable AI b√°sico)
En el RagReportView, a√±ade una secci√≥n:
"¬øPor qu√© esto es relevante?"
"Este p√°rrafo se ha seleccionado porque menciona 'modelo X' y tu documento habla de 'pieza Y', que hist√≥ricamente son incompatibles seg√∫n el manual Z."
No es tecnicamente complejo (es metadata del chunk), pero vende la visi√≥n de "sistema experto" vs "base de datos".
5. La Estrategia de "Falsa Especificidad"
Aqu√≠ est√° el truco psicol√≥gico para no ahuyentar clientes mientras preparas la versi√≥n universal:
Vende "Especializaci√≥n Vertical", entrega "Flexibilidad Horizontal".
Landing page espec√≠fica por vertical:
tudominio.com/sectores/legal ‚Üí Mira c√≥mo analizamos contratos.
tudominio.com/sectores/sanidad ‚Üí Gesti√≥n de historiales cl√≠nicos.
Internamente, es la misma app con config={legal_mode}.
Onboarding con "Templates":
Cuando se registran, preguntan: "¬øDe qu√© sector eres?"
Si dice "Legal", precarga la ontolog√≠a "Causas/Expedientes".
Si dice "Sanidad", precarga "Pacientes/Consultas".
El usuario percibe: "Est√° hecho a medida para m√≠".
T√∫ sabes: "Es configuraci√≥n JSON".
Resumen: No est√°s lejos, est√°s en la curva correcta
Tu c√≥digo actual es la Versi√≥n 1.0 del Cerebro Universal, simplemente con la ontolog√≠a hardcodeada a "ascensores".
El camino es:
Des-hardcodificar nombres (semana 1)
Configurar entidades din√°micamente (mes 2-3)
A√±adir relaciones sem√°nticas (mes 4-6)
Empieza por el Abogado como segundo nicho (es muy similar a "pedidos" - documentos de entrada, an√°lisis de riesgo, formalizaci√≥n de salida).
Y recuerda: Vende el resultado, no la tecnolog√≠a. No digas "usamos RAG", di "nunca m√°s se te escapar√° una cl√°usula peligrosa".
dame todo esto para poderselo plantear al equipo t√©cnico de desarollo, que vean claro qu√© pasos seguir, qu√© tienen que usar en cada caso, qu√© tienen que tirar, reaprovechar, cambiar. No quiero c√≥digo fuente, quiero un roadmap para los desarrolladores. Evita usar herramientas de pago, si no es posible, que tengan un plan gratuito aunque sea limitado.


ROADMAP T√âCNICO: DE PLATAFORMA VERTICAL A MOTOR UNIVERSAL
Migraci√≥n incremental sin parar desarrollo actual
üìã RESUMEN EJECUTIVO PARA EL EQUIPO
Misi√≥n: Convertir el c√≥digo actual (espec√≠fico para ascensores) en una arquitectura meta-modelo que sirva para cualquier vertical (legal, sanidad, gobierno) sin reescribir desde cero.
Estrategia: Refactorizaci√≥n por capas. El c√≥digo que hoy procesa "pedidos" ma√±ana procesar√° "causas" o "pacientes" cambiando solo configuraci√≥n, no l√≥gica.
Restricci√≥n: Stack 100% Open Source o Free Tier perpetuo.
üóëÔ∏è INVENTARIO: QU√â TIRAR, QU√â MANTENER
‚úÖ SE MANTIENE (Core Inmutable)
Next.js 14+ (App Router) - Base s√≥lida
MongoDB Atlas - Capa documental/principal (free tier 512MB-5GB)
NextAuth.js v5 - Autenticaci√≥n (adapter MongoDB gratuito)
Zod - Validaci√≥n runtime (ya lo usan)
Tailwind + Shadcn/UI - Sistema de dise√±o
Custom Hooks (useApi, useApiMutation) - Abstracci√≥n HTTP
Middleware de seguridad - Rate limiting, tenant isolation
Sistema de embeddings - L√≥gica de chunks y vectores
üîß SE REFACTORIZA (Cambia Implementaci√≥n)
Schemas Zod est√°ticos ‚Üí Generadores din√°micos
P√°ginas espec√≠ficas (/pedidos, /documentos) ‚Üí Rutas din√°micas /[entityType]
Workflow hardcodeado ‚Üí Motor de estados configurable
MongoDB √∫nico ‚Üí MongoDB + Graph DB (relaciones)
üóëÔ∏è SE ELIMINA (Deuda t√©cnica)
Textos hardcodeados ("Pedido", "Motor", "Ascensor") en c√≥digo fuente
Enumera√ß√µes est√°ticas de estados ('ingresado' | 'analizado')
Formularios React est√°ticos (cambian por generadores din√°micos)
L√≥gica de negocio espec√≠fica de elevadores mezclada con gen√©rica
üõ†Ô∏è STACK ADICIONAL REQUERIDO (Gratuito/Open Source)
Table
Copy
Capa	Herramienta	Licencia	Reemplaza/Complementa
Graph Database	Neo4j Community Edition	GPL	Relaciones sem√°nticas entre documentos (instalable local o Docker)
State Management	Zustand	MIT	Prop drilling en formularios din√°micos
Formularios Din√°micos	React Hook Form + Resolver	MIT	Formularios hardcodeados actuales
Visualizaci√≥n Grafo	React Flow	MIT	Vistas de relaciones entre entidades
ORM/Type Safety	Prisma (con MongoDB)	Apache 2.0	Queries directas a Mongo (mejor typing)
Feature Flags	Flagsmith (Self-hosted) o Unleash	MIT	Migraci√≥n gradual sin romper nada
Colas/Background	BullMQ (Redis)	MIT	Procesamiento async de documentos (actualmente sync)
B√∫squeda Avanzada	Meilisearch (self-hosted)	MIT	B√∫squeda textual r√°pida (alternativa a Mongo text search)
Nota: Neo4j Community permite producci√≥n sin coste. Alternativa: ArangoDB (Apache 2.0) si prefieren multi-modelo.
üó∫Ô∏è ROADMAP T√âCNICO POR FASES
FASE 0: PREPARACI√ìN (Semanas 1-2)
Objetivo: Desacoplar sin romper. Crear "Feature Flags" para desarrollo paralelo.
Tareas T√©cnicas:
Instalar Flagsmith (self-hosted) o crear tabla feature_flags en Mongo
Flag: DYNAMIC_ENTITIES_ENABLED (false por defecto)
Flag: GRAPH_RELATIONS_ENABLED
Reestructurar carpetas:
Copy
src/
‚îú‚îÄ‚îÄ core/                 # NUEVO: Motor universal
‚îÇ   ‚îú‚îÄ‚îÄ entity-engine/    # L√≥gica gen√©rica de entidades
‚îÇ   ‚îî‚îÄ‚îÄ ontology/         # Configuraci√≥n din√°mica
‚îî‚îÄ‚îÄ verticals/            # MUEVEN: C√≥digo espec√≠fico
    ‚îî‚îÄ‚îÄ elevators/        # Todo lo de ascensores va aqu√≠
Refactor "pnemonic": Renombrar internamente Pedido ‚Üí EntityInstance en tipos TypeScript (alias mantienen compatibilidad).
Entregable: App sigue funcionando igual, pero c√≥digo organizado para bifurcaci√≥n.
FASE 1: META-MODELO (Semanas 3-5)
Objetivo: Las entidades ya no son c√≥digo, son configuraci√≥n JSON.
Implementaci√≥n T√©cnica:
Crear OntologyService:
Nueva colecci√≥n Mongo: tenant_ontologies
Schema: { tenantId, entityTypes: [{name, fields, validations, workflows}] }
Refactor API Layer:
Mantener: /api/tecnico/pedidos/* (legacy)
Crear: /api/core/entities/[entityType]/* (nuevo)
Dynamic routing en Next.js: app/api/core/entities/[type]/route.ts
Generador Zod Runtime:
Funci√≥n buildZodSchema(entityConfig) que genera validadores din√°micos
Reemplaza los archivos est√°ticos PedidoSchema.ts, CasoSchema.ts
Database Strategy:
Mantener Mongo para datos (universal)
Crear colecci√≥n entity_data con campos flexibles (usar MongoDB Schema Validation opcional)
Qu√© tiran: Schemas est√°ticos hardcodeados, endpoints espec√≠ficos duplicados.
Qu√© mantienen: L√≥gica de negocio gen√©rica (validaciones, permisos).
FASE 2: UI DIN√ÅMICA (Semanas 6-8)
Objetivo: Un √∫nico componente <EntityManager /> sirve para casos, pedidos, pacientes, etc.
Stack: React Hook Form + Zustand + Shadcn dynamic
Implementaci√≥n:
Crear componentes gen√©ricos:
DynamicDataTable: Recibe columnsConfig desde API, no hardcodeado
DynamicForm: Renderiza inputs basado en field.type (string, number, date, relation)
EntityLayout: Wrapper que lee configuraci√≥n de sidebar/men√∫ seg√∫n tenant
Sistema de Rutas Din√°micas:
Cambiar: app/(authenticated)/pedidos/page.tsx
Por: app/(authenticated)/[vertical]/[entity]/page.tsx
Ejemplo real: /legal/causas/123 o /medical/pacientes/456
Adapter Pattern:
Crear hooks: useEntity(entityType) que expone create(), update(), list()
Reemplaza usePedidos(), useCasos() espec√≠ficos
Entregable: Pueden crear una nueva vertical (ej: "legal") solo subiendo JSON de configuraci√≥n, sin tocar React.
FASE 3: KNOWLEDGE GRAPH LITE (Semanas 9-11)
Objetivo: Los documentos/de datos se relacionan sem√°nticamente, no solo por b√∫squeda.
Stack: Neo4j Community + React Flow
Implementaci√≥n:
Integraci√≥n Neo4j (Docker local o Atlas):
Nodos: Document, Entity, Chunk
Relaciones: REFERENCES, CONTRADICTS, VERSION_OF, BELONGS_TO
Servicio de Relaciones:
Cuando se sube documento, extraer entidades mencionadas (NER b√°sico o keywords) y crear nodos relaci√≥n
API endpoint: /api/relations/[entityId] devuelve grafo conectado
Visualizaci√≥n:
Implementar React Flow en ruta /explore
Vista nodos/aristas interactiva (arrastrar, hacer click para ver documento)
RAG Mejorado:
Modificar hybridSearch para consultar tanto Mongo (vectorial) como Neo4j (relacional)
"Dame chunks similares + documentos relacionados con este caso"
Qu√© mantienen: Sistema actual de chunks/embeddings (se enriquece, no se reemplaza).
FASE 4: VERTICALIZACI√ìN Y ONBOARDING (Semanas 12-14)
Objetivo: Sistema funciona para cualquier industria sin c√≥digo nuevo.
Implementaci√≥n:
Template System:
JSONs predefinidos: legal-template.json, medical-template.json, elevator-template.json
Script de seeding: npm run seed:vertical legal
Ontology Builder UI:
CRUD simple en /admin/schema-builder (drag & drop b√°sico de campos)
Permite al admin del tenant a√±adir campos custom sin desarrollador
Migraci√≥n Legacy:
Script ETL: Transformar colecci√≥n pedidos actual a formato entity_data universal
Mantener ambas colecciones en paralelo durante transici√≥n (eventual consistency)
Demo Mode:
Switch en landing: "Ver modo Legal" / "Ver modo Sanidad"
Cambia tenantId de demo y carga ontolog√≠a diferente
Entregable: Pueden vender a un despacho de abogados usando el mismo deploy que el cliente de ascensores, solo cambiando configuraci√≥n.
‚ö†Ô∏è RIESGOS T√âCNICOS Y MITIGACI√ìN
Table
Copy
Riesgo	Probabilidad	Impacto	Mitigaci√≥n
Performance de queries din√°micas	Media	Alto	√çndices MongoDB por tenantId + entityType + updatedAt. Paginaci√≥n agresiva (cursor-based)
TypeScript pierde tipado	Alta	Medio	Usar z.infer<> din√°mico + comentarios JSDoc en componentes gen√©ricos. Generadores de tipos opcional post-Fase 2
MongoDB sin schema r√≠gido	Media	Medio	Implementar validaci√≥n Zod antes de insertar (ya lo hacen). Usar MongoDB Schema Validation como guarda adicional
Complejidad Graph DB	Media	Medio	Empezar con relaciones simples (1-1, 1-N). No usar Cypher complejo inicialmente
Team adoption	Alta	Alto	Fase 0 y 1 en paralelo a features actuales. No parar desarrollo de valor, solo refactorizar cuando toquen c√≥digo legacy
üéØ CHECKLIST PARA EMPEZAR (Pr√≥xima semana)
Devs Backend:
[ ] Instalar Neo4j Community local (Docker: docker run -p 7474:7474 -p 7687:7687 neo4j:latest)
[ ] Crear colecci√≥n tenant_ontologies con schema base
[ ] Refactorizar PedidoSchema a funci√≥n generadora createEntitySchema(config)
[ ] Endpoint de prueba: POST /api/core/entities/test que valide JSON contra schema din√°mico
Devs Frontend:
[ ] Instalar Zustand y React Hook Form
[ ] Crear componente DynamicField que renderice Input/TextArea/Select seg√∫n prop type
[ ] Mover carpeta pedidos a verticals/elevators/pedidos (cambio de paths)
[ ] Crear route handler din√°mico [entity]/page.tsx que lea de API qu√© campos mostrar
DevOps/Infra:
[ ] Setear Flagsmith self-hosted o tabla de flags en Mongo existente
[ ] Docker Compose local con: Next.js + Mongo + Neo4j + Redis (para BullMQ futuro)
üí° NOTA FINAL PARA EL EQUIPO
No est√°n construyendo una app de gesti√≥n documental. Est√°n construyendo un "constructor de apps de gesti√≥n documental".
La diferencia es que cada l√≠nea de c√≥digo nueva debe preguntarse: "¬øEsto sirve para un abogado y para un m√©dico, o solo para un t√©cnico de ascensores?"
Si la respuesta es "solo ascensores", esa l√≠nea va a /verticals/elevators/, no al core.
El cliente de ascensores no notar√° diferencia durante la migraci√≥n (gracias a los feature flags). El cliente legal nuevo ver√° una app hecha "a medida" sin haber escrito c√≥digo espec√≠fico para √©l.

DOCUMENTO DE ARQUITECTURA DETALLADA: MIGRACI√ìN A MOTOR UNIVERSAL
Especificaci√≥n t√©cnica para desarrolladores - Nivel de implementaci√≥n
1. ARQUITECTURA META: EL PATR√ìN "HEXAGONAL ADAPTATIVO"
No usaremos arquitectura monol√≠tica ni microservicios. Usaremos Arquitectura Hexagonal con Ports & Adapters, pero con una capa adicional de "Configuraci√≥n Ontol√≥gica".
Concepto Central: El "Entity Engine"
En lugar de tener:
Controller ‚Üí Service ‚Üí Repository ‚Üí Model (MVC tradicional)
Tendremos:
Copy
Route Handler ‚Üí EntityEngine (Port) ‚Üí Adapters (Mongo/Neo4j/FS)
                    ‚Üì
            Ontology Registry (JSON Config)
EntityEngine es una clase/factory que recibe:
tenantId: "lawfirm_123"
entityType: "causa"
operation: "create" | "list" | "update" | "relate"
Y devuelve el comportamiento espec√≠fico leyendo del Registry.
2. ESTRUCTURA DE CARPETAS DETALLADA (Fase 0-1)
Copy
src/
‚îú‚îÄ‚îÄ app/                              # Next.js App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ legacy/                   # MANTENER: API actual funcionando
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v2/                       # NUEVO: API din√°mica
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ [tenantId]/
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ [entityType]/
‚îÇ   ‚îÇ                   ‚îî‚îÄ‚îÄ route.ts  # Handler √∫nico gen√©rico
‚îÇ   ‚îî‚îÄ‚îÄ (authenticated)/
‚îÇ       ‚îú‚îÄ‚îÄ legacy/                   # P√°ginas actuales (fallback)
‚îÇ       ‚îî‚îÄ‚îÄ workspace/
‚îÇ           ‚îî‚îÄ‚îÄ [[...slug]]/          # Catch-all para rutas din√°micas
‚îÇ               ‚îî‚îÄ‚îÄ page.tsx          # Componente orquestador
‚îú‚îÄ‚îÄ core/                             # NUEVO: Motor universal (sin UI)
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ontology.ts           # Contratos TypeScript base
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ engine/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ EntityEngine.ts       # Orquestador principal
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ validators/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ZodGenerator.ts   # Factory de schemas
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ MongoAdapter.ts   # CRUD documental
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ GraphAdapter.ts   # Relaciones (Neo4j)
‚îÇ   ‚îî‚îÄ‚îÄ registry/                     # Configuraciones
‚îÇ       ‚îú‚îÄ‚îÄ legal-ontology.json
‚îÇ       ‚îú‚îÄ‚îÄ medical-ontology.json
‚îÇ       ‚îî‚îÄ‚îÄ elevator-ontology.json
‚îú‚îÄ‚îÄ verticals/                        # C√≥digo espec√≠fico (a eliminar gradualmente)
‚îÇ   ‚îî‚îÄ‚îÄ elevators/
‚îÇ       ‚îú‚îÄ‚îÄ components/               # UI espec√≠fica ascensores
‚îÇ       ‚îî‚îÄ‚îÄ hooks/
‚îú‚îÄ‚îÄ lib/                              # Actual - se mantiene
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îî‚îÄ‚îÄ db.ts
‚îî‚îÄ‚îÄ shared/                           # Componentes UI gen√©ricos
    ‚îú‚îÄ‚îÄ forms/
    ‚îÇ   ‚îî‚îÄ‚îÄ DynamicForm.tsx           # Generador de formularios
    ‚îú‚îÄ‚îÄ tables/
    ‚îÇ   ‚îî‚îÄ‚îÄ DynamicTable.tsx          # Tabla con columnas config
    ‚îî‚îÄ‚îÄ graph/
        ‚îî‚îÄ‚îÄ RelationGraph.tsx         # Visualizador React Flow
Clave: La carpeta core/ no importa nada de app/ ni verticals/. Es pura l√≥gica de negocio testeable unitariamente.
3. FASE 0: DUALIDAD SIN RUPTURA (Detalle)
El Patr√≥n "Strangler Fig"
No cambiamos rutas antiguas. Creamos paralelo y redirigimos progresivamente.
Implementaci√≥n espec√≠fica:
Router Inteligente en middleware:
Leer header X-Client-Version: v2 o cookie useNewUI=true
Si activo: Rewrite /pedidos ‚Üí /workspace/elevators/pedidos
Si no: Flujo normal legacy
Base de Datos Dual:
Colecci√≥n existente: pedidos (sigue funcionando)
Nueva colecci√≥n: unified_entities con estructura:
TypeScript
Copy
{
  _id: ObjectId,
  tenantId: string,
  entityType: "pedido" | "causa" | "paciente",
  payload: object,  // Schema din√°mico validado por Zod
  relations: Array<{targetId, relationType}>,
  meta: {
    source: "legacy" | "v2",
    version: 1
  }
}
Sync Service:
Worker que escucha Mongo Change Streams en pedidos
Cuando detecta cambio: replica en unified_entities con transformaci√≥n
Esto permite tener ambas versiones sincronizadas durante migraci√≥n
4. FASE 1: MOTOR DE ENTIDADES (Especificaci√≥n T√©cnica)
4.1 El Registry: Ontolog√≠a Declarativa
Cada vertical es un archivo JSON que describe el mundo:
JSON
Copy
{
  "id": "legal-basic",
  "version": "1.0.0",
  "entities": [
    {
      "name": "causa",
      "plural": "causas",
      "fields": [
        {
          "key": "numero_judicial",
          "type": "string",
          "validation": { "required": true, "pattern": "^[0-9]{4}/[0-9]{4}$" },
          "ui": { "label": "N√∫mero de autos", "component": "input", "order": 1 }
        },
        {
          "key": "juzgado",
          "type": "relation",
          "targetEntity": "juzgado",
          "relationType": "many-to-one",
          "ui": { "component": "select-search" }
        },
        {
          "key": "documentacion",
          "type": "files",
          "accept": ["pdf", "docx"],
          "maxSize": 10485760
        }
      ],
      "workflows": ["inicio", "admision", "prueba", "sentencia", "archivo"],
      "permissions": {
        "TECNICO": ["read", "create"],
        "ADMIN": ["read", "create", "update", "delete"]
      },
      "ragContext": {
        "chunkableFields": ["hechos", "pretensiones"],
        "searchable": true
      }
    }
  ]
}
Gesti√≥n: Estos JSON se almacenan en Mongo en colecci√≥n ontologies, se cachean en Redis (si lo tienen) o en memoria del servidor Next.js con revalidaci√≥n cada 5 minutos.
4.2 EntityEngine: Ciclo de Vida
Paso 1: Bootstrapping (Build Time)
Script npm run build:ontologies lee JSONs y genera:
Tipos TypeScript (.d.ts) para autocomplete b√°sico
Migraciones Mongo (√≠ndices necesarios por tipo de entidad)
Paso 2: Runtime (Request)
Validaci√≥n: ZodGenerator.create(ontology) compila schema en caliente
Adaptaci√≥n: Seg√∫n operaci√≥n, elige adapter:
Create/Update/List ‚Üí MongoAdapter
Relate/Graph queries ‚Üí GraphAdapter
Complex validation ‚Üí CompositeAdapter (ambos)
Paso 3: Ejecuci√≥n
MongoAdapter usa colecci√≥n entities con campo discriminator entityType
GraphAdapter usa Neo4j con nodos :Entity y propiedades tenantId, type
4.3 Migraci√≥n de Datos (Script One-Off)
Para cada vertical nuevo:
bash
Copy
# Ejemplo: migrar cliente legal existente con datos legacy
npm run migrate:vertical \
  --from=legacy \
  --to=unified \
  --tenant=lawfirm_123 \
  --ontology=./registry/legal-ontology.json
Estrategia de transformaci√≥n:
Mapeo de campos: numero_expediente (legacy) ‚Üí numero_judicial (nuevo)
Enriquecimiento: Al migrar, extraer keywords y crear nodos en Grafo
Validaci√≥n: Si un registro legacy falla validaci√≥n nueva, se marca como legacy_dirty para revisi√≥n manual
5. FASE 2: UI DIN√ÅMICA (Arquitectura de Componentes)
5.1 El Sistema de Formularios
No usaremos React Hook Form tradicional. Usaremos "JSON Schema Forms" con controladores espec√≠ficos.
Flujo de renderizado:
Componente EntityForm recibe prop entityType="causa"
Fetch a API: GET /api/v2/schema/causa (devuelve definici√≥n campos)
Resolver Din√°mico:
Itera campos y genera componentes Shadcn correspondientes:
"string" ‚Üí <Input />
"relation" ‚Üí <ComboboxSearchable /> (conecta a API de entidad relacionada)
"files" ‚Üí <UploadZone />
"rich_text" ‚Üí <TiptapEditor />
Validaci√≥n Client-Side: Schema Zod generado din√°micamente importado v√≠a dynamic import para no pesar bundle inicial
5.2 El Sistema de Tablas
Problema: Lista de campos variable, ordenamiento, filtros.
Soluci√≥n: TanStack Table (React Table v8) con configuraci√≥n din√°mica:
TypeScript
Copy
// ColumnHelper gen√©rico
function generateColumns(entityConfig): ColumnDef[] {
  return entityConfig.fields.map(field => ({
    accessorKey: field.key,
    header: field.ui.label,
    filterFn: getFilterFn(field.type), // 'text', 'select', 'dateRange'
    cell: ({ getValue }) => <CellRenderer type={field.type} value={getValue()} />
  }));
}
Optimizaci√≥n: Virtualizaci√≥n obligatoria si >100 filas (react-virtual).
5.3 Navegaci√≥n Adaptativa
El men√∫ sidebar ya no es est√°tico. Es generado:
TypeScript
Copy
// useNavigation hook
const buildNavigation = (ontology) => ({
  items: ontology.entities.map(e => ({
    label: e.plural,
    href: `/workspace/${tenantId}/${e.name}`,
    icon: getIconForEntity(e.name), // Mapeo nombre ‚Üí icono
    badge: e.workflow?.states // Mostrar contadores por estado si existe workflow
  }))
});
6. FASE 3: GRAFO DE RELACIONES (Implementaci√≥n Neo4j)
6.1 Modelo de Datos en Grafo
Nodos:
(:Entity {id, tenantId, type, createdAt}) - Representa la cabecera
(:Document {id, name, embeddingId}) - Archivos f√≠sicos
(:Concept {name, type}) - Entidades nombradas extra√≠das (NER)
Relaciones:
(e:Entity)-[:HAS_DOCUMENT]->(d:Document)
(e1:Entity)-[:RELATES_TO {type: "parent", strength: 0.9}]->(e2:Entity)
(d:Document)-[:MENTIONS]->(c:Concept)
6.2 Sincronizaci√≥n Eventual Mongo ‚Üî Neo4j
Patr√≥n CQRS Liviano:
Writes (crear/editar): Van a Mongo (source of truth)
Evento disparado (Change Stream de Mongo)
Worker actualiza Neo4j para consultas de relaciones
Consultas cruzadas:
Copy
Usuario busca: "causas relacionadas con el juzgado 5"
‚Üì
API consulta Neo4j: MATCH (e:Entity)-[:RELATES_TO]-(j:Concept {name:"Juzgado 5"})
‚Üì
Obtiene IDs de entidades
‚Üì
Fetch a Mongo para datos completos (payload)
6.3 UI del Grafo
React Flow configuraci√≥n:
Nodos personalizados seg√∫n tipo (Causa = color azul, Documento = gris)
Layout autom√°tico: dagre o elk.js (algoritmos de posicionamiento)
Interacci√≥n: Click nodo ‚Üí Panel lateral con detalles (sin salir de vista)
7. FASE 4: VERTICALIZACI√ìN Y TEMPLATES
7.1 Template System
Estructura de un Template:
Copy
templates/
‚îî‚îÄ‚îÄ legal/
    ‚îú‚îÄ‚îÄ ontology.json           # Definici√≥n estructura
    ‚îú‚îÄ‚îÄ seed/
    ‚îÇ   ‚îî‚îÄ‚îÄ demo-data.json      # Casos de ejemplo para demo
    ‚îú‚îÄ‚îÄ workflows/
    ‚îÇ   ‚îî‚îÄ‚îÄ default.json        # Estados y transiciones
    ‚îî‚îÄ‚îÄ prompts/                # Prompts espec√≠ficos para IA
        ‚îî‚îÄ‚îÄ extraction.txt
Proceso de Onboarding:
Usuario selecciona: "Soy despacho de abogados"
Sistema ejecuta: TemplateInstaller.install('legal', tenantId)
Crea:
Registro en colecci√≥n ontologies
Colecci√≥n Mongo entities_lawfirm_123 (o usa discriminator en colecci√≥n √∫nica)
√çndices espec√≠ficos (ej: texto en campo "hechos")
Datos demo opcionales
7.2 Customizaci√≥n por Tenant
Nivel 1: Campos Custom (Seguro, simple)
Admin a√±ade campo codigo_interno a entidad causa
Se almacena en entity.payload como campo libre
UI lo muestra autom√°ticamente
Nivel 2: Hooks/Validaciones Custom (Avanzado)
Sistema de plugins: Permitir subir funci√≥n serverless (Vercel Edge Function) que se ejecute pre-save
Ejemplo: "Validar que n√∫mero judicial no exista ya en BD externa"
8. TESTING Y VALIDACI√ìN POR FASE
Fase 0
[ ] Tests E2E existentes siguen pasando (regresi√≥n cero)
[ ] Flags funcionan correctamente (activar/desactivar)
Fase 1
[ ] Script de migraci√≥n idempotente (puedes correrlo varias veces sin duplicar)
[ ] Benchmark: Tiempo de validaci√≥n Zod din√°mica < 50ms (caching)
[ ] Test: Crear entidad tipo "test" via API y que se persista correctamente
Fase 2
[ ] Test visual: Formulario generado renderiza correctamente en m√≥vil
[ ] Test de usabilidad: Usuario sin conocimiento t√©cnico puede crear registro nuevo
Fase 3
[ ] Test de integridad: Borrar entidad en Mongo borra nodo en Neo4j (consistencia)
[ ] Performance: Grafo con 1000 nodos renderiza en < 2 segundos
Fase 4
[ ] Demos paralelas: Puedes mostrar "modo legal" y "modo m√©dico" en tabs diferentes simult√°neamente sin conflicto de sesi√≥n
9. DECISIONES T√âCNICAS CR√çTICAS (Para discutir en equipo)
A. Single Collection vs Multi-Collection
Opci√≥n A (Recomendada): Una colecci√≥n entities con √≠ndice compuesto {tenantId: 1, entityType: 1}
Pros: M√°s simple,aprovecha √≠ndices de Mongo, f√°cil backup
Cons: Schema menos estricto (pero Zod lo controla app-level)
Opci√≥n B: Colecci√≥n por tenant (entities_tenant_123) o por tipo (pedidos, causas)
Pros: Aislamiento f√≠sico total, schemas opcionalmente r√≠gidos
Cons: Complejidad operativa (muchas colecciones), queries cross-entity imposibles
B. Graph DB: Neo4j vs ArangoDB
Neo4j Community:
Pros: Cypher m√°s maduro, mejor documentaci√≥n, integraciones
Cons: Limitado a un solo nodo en Community (no clustering)
ArangoDB:
Pros: Multi-modelo (grafo + documental), puedes eliminar Mongo y tener todo en uno
Cons: M√°s complejo, menos optimizado para puras relaciones
Decisi√≥n: Neo4j Community (simplicidad), con opci√≥n de pasar a AuraDB Free (cloud) si necesitan escalabilidad sin gestionar servidores.
C. Validaci√≥n: Zod vs JSON Schema
Zod: Ya lo usan. Permite inferir tipos TypeScript. Mejor DX.
JSON Schema: Est√°ndar universal. Permite validar en m√∫ltiples lenguajes.
Decisi√≥n: Zod para runtime, generar JSON Schema desde Zod si necesitan interoperabilidad externa.
10. CHECKLIST DE "GO/NO-GO" POR FASE
Antes de pasar de Fase 1 a 2:
[ ] ¬øEl EntityEngine soporta transacciones (create entity + relations at√≥micas)?
[ ] ¬øEl fallback a legacy funciona si el dyn√°mico falla?
[ ] ¬øPodemos crear un nuevo tipo de entidad sin desplegar c√≥digo (solo subiendo JSON)?
Antes de pasar de Fase 2 a 3:
[ ] ¬øLa latencia de crear un registro es < 300ms incluyendo validaci√≥n?
[ ] ¬øFunciona offline-first o al menos offline-tolerant (form drafts)?
Antes de Fase 4:
[ ] ¬øUn cliente puede personalizar su ontolog√≠a sin llamar al equipo de desarrollo?
Conclusi√≥n para el equipo: Esto no es una reescritura. Es una refactorizaci√≥n de arquitectura guiada por configuraci√≥n. El c√≥digo que escrib√°is en Fase 1 (EntityEngine) es el √∫ltimo c√≥digo espec√≠fico que escribir√©is para CRUDs. Despu√©s, todo es configuraci√≥n.