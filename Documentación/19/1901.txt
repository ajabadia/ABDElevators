 AnÃ¡lisis de tu Arquitectura Actual
Fortalezas Consolidadas (Multi-Vertical)
Table
Copy
Componente	ImplementaciÃ³n	ObservaciÃ³n
Tenant Isolation	getTenantCollection(), tenantId en todas las colecciones	âœ… SÃ³lido para multi-tenant
Industry Detection	session.user.industry en document-types/route.ts	âœ… Base para routing de dominio
Scope System	GLOBAL / INDUSTRY / TENANT en document types	âœ… JerarquÃ­a de visibilidad
Environment Separation	STAGING / PRODUCTION en prompts	âœ… Buena para testing
RAG Evaluation	rag_evaluations collection	âœ… MÃ©tricas bÃ¡sicas implementadas
Hybrid Search	hybridSearch() en rag-service	âœ… CombinaciÃ³n vector + keyword
âš ï¸ Brechas Identificadas para Multi-Vertical
1. Falta de Domain Router en el Pipeline RAG
Tu cÃ³digo en document-types/route.ts filtra por industry, pero el RAG en sÃ­ no parece tener un router que clasifique queries por dominio antes de retrieval:
TypeScript
Copy
// CÃ“DIGO ACTUAL (en document-types/route.ts):
// Filtrado pasivo por industry, pero no hay clasificaciÃ³n activa de la query

const filteredTypes = isSuperAdmin ? types : types.filter((t: any) => {
    if (t.scope === 'GLOBAL') return true;
    if (t.scope === 'TENANT') return true;
    if (t.scope === 'INDUSTRY') {
        const allowedIndustries = t.industries || [];
        if (t.industry) allowedIndustries.push(t.industry);
        return allowedIndustries.includes(userIndustry); // userIndustry viene de sesiÃ³n, no de la query
    }
    return true;
});
Mejora propuesta - Domain Router:
TypeScript
Copy
// NUEVO: /lib/domain-router.ts
interface DomainClassification {
    primaryDomain: 'legal' | 'insurance' | 'healthcare' | 'banking' | 'elevators' | 'generic';
    confidence: number;
    subDomain?: string;
    intent: 'retrieval' | 'comparison' | 'compliance_check' | 'diagnostic';
    requiresCrossDomain: boolean;
}

class DomainRouter {
    async classify(query: string, tenantContext: TenantContext): Promise<DomainClassification> {
        // OpciÃ³n 1: Usar LLM con few-shot examples por vertical
        // OpciÃ³n 2: Embedding similarity contra descripciones de dominio
        
        const domainDescriptions = {
            legal: "contratos, jurisprudencia, normativa, litigios, derecho laboral, mercantil",
            insurance: "pÃ³lizas, siniestros, reaseguro, actuarial, riesgos, coberturas",
            healthcare: "clÃ­nico, diagnÃ³stico, tratamientos, farmacologÃ­a, evidencia mÃ©dica",
            banking: "regulatorio, riesgo crediticio, compliance, productos financieros",
            elevators: "mantenimiento, normativa tÃ©cnica, componentes, seguridad industrial"
        };
        
        // ImplementaciÃ³n con embeddings...
    }
}
2. Prompts Sin Contexto de Dominio EspecÃ­fico
En admin/prompts/page.tsx tienes categorÃ­as (EXTRACTION, ANALYSIS, RISK, CHECKLIST, GENERAL) pero no hay dimensiÃ³n de dominio vertical:
TypeScript
Copy
// CÃ“DIGO ACTUAL:
const CATEGORIES = ['EXTRACTION', 'ANALYSIS', 'RISK', 'CHECKLIST', 'GENERAL'];

// MEJORA PROPUESTA:
interface DomainPrompt extends Prompt {
    domain: 'legal' | 'insurance' | 'healthcare' | 'banking' | 'elevators' | 'generic';
    subDomain?: string;
    domainContext: {
        terminology: string[];
        regulatoryFramework: string[];
        standardProcedures: string[];
        forbiddenOutputs: string[];
    };
    reasoningTemplate: string; // Chain-of-thought especÃ­fico del dominio
}
3. Vector Search No Segmentado por Dominio
Tu hybridSearch (referenciado en chunks/route.ts) parece usar un Ãºnico espacio vectorial. Para multi-vertical, deberÃ­as considerar:
TypeScript
Copy
// MEJORA PROPUESTA: ConfiguraciÃ³n por tenant
interface TenantRAGConfig {
    vectorSpaces: {
        [domain: string]: {
            indexName: string;           // "vs_legal_contracts", "vs_medical_records"
            embeddingModel: string;      // Diferente modelo por dominio si es necesario
            chunkStrategy: 'semantic' | 'fixed' | 'hierarchical';
            domainSpecialTokens: string[]; // TÃ©rminos clave del dominio
        }
    };
    
    // Para tenants multi-vertical (consultoras, grandes firmas)
    crossDomainSearch: {
        enabled: boolean;
        mergeStrategy: 'union' | 'intersection' | 'weighted';
        domainWeights: Record<string, number>;
    };
}
4. Entity Engine GenÃ©rico pero Sin Mapeo de Dominio
Tu EntityEngine en entities/page.tsx es potente:
TypeScript
Copy
// CÃ“DIGO ACTUAL:
const entity = EntityEngine.getInstance().getEntity('pedido')!;
Pero podrÃ­a expandirse para cross-domain:
TypeScript
Copy
// MEJORA PROPUESTA:
interface EntityDefinition {
    slug: string; // "claim", "policy", "case", "patient_record"
    
    // Mapeo por vertical (misma entidad, diferentes nombres)
    domainAliases: {
        insurance: { name: 'claim', plural: 'claims', icon: 'Shield' };
        legal: { name: 'case', plural: 'cases', icon: 'Scale' };
        healthcare: { name: 'episode', plural: 'episodes', icon: 'HeartPulse' };
        banking: { name: 'incident', plural: 'incidents', icon: 'AlertCircle' };
    };
    
    // Campos abstractos comunes con mapeo especÃ­fico
    abstractFields: {
        identifier: { type: 'string', required: true };
        status: { type: 'enum', values: ['open', 'pending', 'resolved', 'closed'] };
    };
    
    domainSpecificFields: {
        insurance: { policy_number: string; loss_date: Date; coverage_type: string };
        legal: { case_type: string; court_jurisdiction: string; opposing_party: string };
    };
}
5. EvaluaciÃ³n de RAG GenÃ©rica
Tu rag_evaluations (visto en admin/page.tsx) tiene mÃ©tricas bÃ¡sicas:
TypeScript
Copy
// CÃ“DIGO ACTUAL (inferido de global-stats):
rag_quality_avg: {
    avgFaithfulness: number;
    avgRelevance: number;
    avgPrecision: number;
}

// MEJORA PROPUESTA - MÃ©tricas por dominio:
interface DomainRAGEvaluation {
    domain: string;
    subDomain?: string;
    
    domainMetrics: {
        terminologyAccuracy: number;      // Â¿UsÃ³ tÃ©rminos correctos del dominio?
        regulatoryCompliance: boolean;    // Â¿ViolÃ³ alguna regla sectorial?
        sourceAuthority: number;          // Â¿CitÃ³ fuentes autoritativas del dominio?
        crossDomainConfusion: boolean;    // Â¿MezclÃ³ conceptos de dominios diferentes?
    };
    
    // Ground truth especÃ­fico por dominio
    expectedAnswer?: {
        legal: string;
        medical: string;
        insurance: string;
    };
}
ğŸš€ Roadmap Priorizado para Multi-Vertical
Table
Copy
Fase	Feature	Impacto	Esfuerzo	Archivos a Modificar
1	Domain Router - ClasificaciÃ³n de queries por dominio	ğŸ”¥ Alto	2-3 dÃ­as	Nuevo: /lib/domain-router.ts, Modificar: /api/search/route.ts
2	Prompts con dimensiÃ³n domain	ğŸ”¥ Alto	3-4 dÃ­as	/app/admin/prompts/page.tsx, /lib/schemas.ts
3	Entity Engine con domainAliases	ğŸ”¥ Alto	1 semana	/core/engine/EntityEngine.ts
4	Vector spaces separados por dominio	âš¡ Medio-Alto	1-2 semanas	/lib/rag-service.ts, /lib/db-tenant.ts
5	Compliance rules por dominio (GDPR, HIPAA, etc.)	âš¡ Medio-Alto	1 semana	Nuevo: /lib/compliance-service.ts
6	Cross-domain search & merge	ğŸ’ Diferenciador	2 semanas	/lib/rag-service.ts
7	EvaluaciÃ³n con mÃ©tricas de dominio	ğŸ’ Diferenciador	3-4 dÃ­as	/app/admin/rag-eval/page.tsx, /lib/schemas.ts
ğŸ’¡ RecomendaciÃ³n Inmediata
Dado que ya tienes la base sÃ³lida, te sugiero empezar por el Domain Router (Fase 1). Esto es low-hanging fruit con alto impacto:
TypeScript
Copy
// ImplementaciÃ³n rÃ¡pida en tu endpoint de bÃºsqueda existente:

// En /api/search/route.ts (o donde tengas el endpoint principal)
export async function POST(req: NextRequest) {
    const { query, tenantId } = await req.json();
    
    // NUEVO: Clasificar dominio
    const domainRouter = new DomainRouter();
    const classification = await domainRouter.classify(query, { tenantId });
    
    // Usar la clasificaciÃ³n para:
    // 1. Seleccionar prompts especÃ­ficos del dominio
    // 2. Filtrar documentos por industry/domain relevante
    // 3. Ajustar el system prompt del LLM con contexto de dominio
    
    const results = await executeDomainAwareRAG(query, tenantId, classification);
    
    return NextResponse.json({ 
        results, 
        meta: { classification } // Opcional: exponer para debugging
    });
}
Â¿Quieres que profundice en alguna de estas Ã¡reas especÃ­ficamente? El Domain Router parece el punto de entrada mÃ¡s impactante para empezar, seguido de la expansiÃ³n de tu Entity Engine para soportar aliases por dominio.
profundiza en estos temas, no es necesario que me des cÃ³digo fuente, porque de eso se encargarÃ¡n los programadores, solo dÃ­me quÃ© hacer y quÃ© modificar
Edit
Copy
Share
Entendido. AquÃ­ tienes la guÃ­a estratÃ©gica sin cÃ³digo, organizada por prioridad de implementaciÃ³n:
1. DOMAIN ROUTER (Prioridad MÃ¡xima)
QuÃ© es
Un clasificador inteligente que analiza cada consulta del usuario y determina a quÃ© dominio vertical pertenece (legal, seguros, sanidad, bancario, elevadores) antes de ejecutar el retrieval.
Por quÃ© es crÃ­tico ahora
Sin esto, una consulta sobre "pÃ³liza" en un tenant multi-vertical buscarÃ¡ en documentaciÃ³n de seguros, derecho contractual y banca simultÃ¡neamente, generando ruido y alucinaciones.
QuÃ© modificar
Nuevo componente a crear:
Servicio de clasificaciÃ³n de dominio con dos opciones: LLM-based (preciso, lento) o embedding-based (rÃ¡pido, suficiente para MVP)
Endpoints a modificar:
Todos los endpoints de bÃºsqueda RAG (/api/search, /api/technical/rag/chat, etc.) deben llamar al Domain Router antes del retrieval
Base de datos:
Nueva colecciÃ³n domain_profiles con descripciones en lenguaje natural de cada dominio para comparaciÃ³n semÃ¡ntica
Ãndice en document_chunks por domain + tenantId
ConfiguraciÃ³n de tenant:
AÃ±adir campo enabledDomains en configuraciÃ³n de tenant para restringir quÃ© dominios puede ver cada organizaciÃ³n
2. PROMPTS CON DIMENSIÃ“N DE DOMINIO
QuÃ© es
Extender tu sistema de prompts actual para que cada prompt estÃ© etiquetado no solo por categorÃ­a (EXTRACTION, ANALYSIS) sino por dominio vertical especÃ­fico.
Por quÃ© es necesario
Un prompt de "extracciÃ³n de entidades" para documentos legales necesita buscar clÃ¡usulas y jurisprudencia; el mismo prompt para sanidad debe buscar sÃ­ntomas y diagnÃ³sticos. Son lÃ³gicas radicalmente diferentes.
QuÃ© modificar
Schema de prompts:
AÃ±adir campo obligatorio domain con valores del enum de dominios
AÃ±adir campo opcional subDomain para especializaciones (ej: "reinsurance_treaty" dentro de insurance)
AÃ±adir objeto domainContext con: terminologÃ­a especÃ­fica, marco regulatorio aplicable, procedimientos estÃ¡ndar del sector, y salidas prohibidas (para compliance)
UI de administraciÃ³n:
En /admin/prompts, aÃ±adir filtro por dominio en el sidebar
Mostrar badge de dominio en cada tarjeta de prompt
Validar que un tenant solo pueda ver prompts de sus dominios habilitados
LÃ³gica de selecciÃ³n:
Modificar el PromptService para que, dada una query ya clasificada por el Domain Router, seleccione automÃ¡ticamente el prompt mÃ¡s especÃ­fico disponible
3. ENTITY ENGINE CON DOMAIN ALIASES
QuÃ© es
Tu Entity Engine actual asume que una entidad "pedido" siempre se llama asÃ­. En multi-vertical, la misma entidad abstracta tiene nombres diferentes: "siniestro" (seguros), "caso" (legal), "episodio" (sanidad).
QuÃ© modificar
DefiniciÃ³n de entidades:
AÃ±adir secciÃ³n domainAliases en cada definiciÃ³n de entidad
Mapear campos abstractos (identifier, status, priority) a nombres concretos por dominio
Definir campos especÃ­ficos por dominio que no existen en otros (ej: policy_number solo en insurance, court_jurisdiction solo en legal)
Motor de resoluciÃ³n:
Modificar EntityEngine.getEntity() para aceptar parÃ¡metro de dominio
Si el usuario pide "claim" y el dominio es insurance, resolver a la entidad genÃ©rica con alias insurance
Si el dominio es legal y pide "claim", sugerir "case" o mostrar ambigÃ¼edad
APIs dinÃ¡micas:
Los endpoints de entidades deben aceptar header o parÃ¡metro X-Domain-Context
Las respuestas deben incluir metadatos de quÃ© alias se usÃ³ para la resoluciÃ³n
4. VECTOR SPACES SEGREGADOS POR DOMINIO
QuÃ© es
En lugar de un Ãºnico Ã­ndice vectorial por tenant, crear Ã­ndices separados por dominio dentro de cada tenant, permitiendo estrategias de retrieval diferenciadas.
QuÃ© modificar
Arquitectura de Ã­ndices:
Cambiar de tenant_vectors a estructura tenant_domain_vectors
Cada espacio puede tener: modelo de embedding diferente (si los dominios lo justifican), estrategia de chunking especÃ­fica, y tokens especiales de dominio inyectados en los embeddings
Pipeline de ingestiÃ³n:
Modificar el servicio de ingestiÃ³n para que, al procesar un documento, detecte su dominio (via metadatos o clasificaciÃ³n automÃ¡tica) y lo indexe en el espacio vectorial correspondiente
Permitir documentos "multi-dominio" que se indexen en mÃºltiples espacios (ej: un contrato de seguro de responsabilidad civil que toca legal + insurance)
ConfiguraciÃ³n de bÃºsqueda:
AÃ±adir campo vectorSpaceConfig en configuraciÃ³n de tenant
Permitir configurar pesos por dominio para tenants multi-vertical (ej: bufete de seguros: 70% legal, 30% insurance)
5. COMPLIANCE Y GOBERNANZA POR DOMINIO
QuÃ© es
Cada vertical tiene regulaciones distintas: GDPR para todos, pero tambiÃ©n HIPAA (sanidad), Solvency II (seguros), PCI-DSS (banca). El RAG debe respetar restricciones diferentes por dominio.
QuÃ© modificar
Sistema de reglas:
Crear mÃ³dulo DomainComplianceRules con configuraciones por dominio
Definir: niveles de retenciÃ³n de datos, requisitos de audit trail, umbrales de confianza para respuestas (mÃ¡s altos en dominios regulados), y listas de lo que el RAG nunca debe generar (ej: consejo mÃ©dico diagnÃ³stico, asesorÃ­a legal vinculante)
IntegraciÃ³n con Guardian:
Extender tu sistema ABAC actual para incluir atributos de dominio en las polÃ­ticas
PolÃ­ticas como "usuarios con rol ANALYST pueden ver respuestas RAG de insurance pero no de banking"
Certificaciones:
AÃ±adir generaciÃ³n automÃ¡tica de reportes de compliance por dominio para auditorÃ­as
6. CROSS-DOMAIN SEARCH (Fase Avanzada)
QuÃ© es
Para consultas ambiguas o explÃ­citamente multi-dominio (ej: "comparar cobertura de pÃ³lizas con precedentes judiciales"), ejecutar bÃºsqueda paralela en mÃºltiples espacios vectoriales y fusionar resultados inteligentemente.
QuÃ© modificar
LÃ³gica de routing:
Extender Domain Router para detectar requiresCrossDomain: true
Casos: confianza baja en clasificaciÃ³n, query contiene tÃ©rminos de mÃºltiples dominios, o usuario explÃ­citamente solicita comparaciÃ³n
Estrategias de merge:
Implementar: uniÃ³n (todos los resultados), intersecciÃ³n (solo relevantes en ambos), ponderado (segÃºn configuraciÃ³n de tenant)
AÃ±adir reranking cross-domain con modelo especÃ­fico que entienda relevancia inter-dominio
PresentaciÃ³n de resultados:
UI debe agrupar resultados por dominio de origen
Indicar visualmente cuando una respuesta combina fuentes de mÃºltiples dominios
7. EVALUACIÃ“N CON MÃ‰TRICAS DE DOMINIO
QuÃ© es
Tu evaluaciÃ³n RAG actual mide faithfulness y relevance genÃ©ricos. Necesitas mÃ©tricas que validen si el sistema entiende correctamente la terminologÃ­a y contexto especÃ­fico de cada vertical.
QuÃ© modificar
Schema de evaluaciones:
AÃ±adir campos de dominio a cada evaluaciÃ³n registrada
MÃ©tricas especÃ­ficas: precisiÃ³n terminolÃ³gica (Â¿usÃ³ el tÃ©rmino tÃ©cnico correcto?), autoridad de fuentes (Â¿citÃ³ el reglamento sectorial adecuado?), confusiÃ³n cross-domain (Â¿mezclÃ³ conceptos incompatibles?)
Ground truth:
Permitir definir respuestas esperadas diferentes por dominio para la misma pregunta abstracta
Sistema de evaluadores humanos especializados por vertical
Dashboard:
Extender /admin/rag-eval para mostrar tendencias separadas por dominio
Alertas cuando la calidad de un dominio especÃ­fico cae por debajo del umbral
Secuencia de ImplementaciÃ³n Recomendada
Table
Copy
Semana	Foco	Dependencias
1-2	Domain Router + modificaciÃ³n de endpoints de bÃºsqueda	Ninguna
3	Prompts con dimensiÃ³n de dominio	Domain Router
4	Entity Engine con domain aliases	Domain Router
5-6	Vector spaces segregados	Domain Router, IngestiÃ³n
7	Compliance por dominio	Domain Router, Guardian
8+	Cross-domain search	Vector spaces segregados
Continuo	EvaluaciÃ³n con mÃ©tricas de dominio	Todo lo anterior
Riesgos a Mitigar
Sobrecarga de complejidad: No activar todos los dominios para todos los tenants. Mantener "generic" como fallback.
Consistencia de datos: Si un documento cambia de dominio (reclasificaciÃ³n), reindexar en el espacio vectorial correcto.
Latencia: El Domain Router aÃ±ade una llamada LLM o embedding adicional. Considerar cachÃ© por patrones de query frecuentes.
Â¿Necesitas que profundice en alguno de estos puntos especÃ­ficos o en la interacciÃ³n entre ellos?
profundiza en la interacciÃ³n entre ellos
Edit
Copy
Share
AquÃ­ tienes el anÃ¡lisis de interacciones entre los componentes, con los flujos de dependencia, puntos de fricciÃ³n potenciales y estrategias de mitigaciÃ³n:
Arquitectura de Interacciones
Diagrama de Dependencias
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DOMAIN ROUTER (Base)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  LLM-based  â”‚  â”‚Embedding-   â”‚  â”‚  Confidence Score   â”‚ â”‚
â”‚  â”‚  (Preciso)  â”‚  â”‚based(RÃ¡pido)â”‚  â”‚  (Umbral decisiÃ³n)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
        â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚PROMPT SERVICE â”‚    â”‚  ENTITY ENGINE  â”‚    â”‚ VECTOR SPACE    â”‚
â”‚  (DimensiÃ³n   â”‚    â”‚  (Domain        â”‚    â”‚  SELECTOR       â”‚
â”‚   Dominio)    â”‚    â”‚   Aliases)      â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  RAG ORCHESTRATORâ”‚
                    â”‚  (IntegraciÃ³n)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                 â”‚                 â”‚
            â–¼                 â–¼                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  COMPLIANCE   â”‚ â”‚  CROSS-DOMAIN â”‚ â”‚  EVALUATION   â”‚
    â”‚    FILTER     â”‚ â”‚    SEARCH     â”‚ â”‚   ENGINE      â”‚
    â”‚  (ValidaciÃ³n) â”‚ â”‚  (Condicional)â”‚ â”‚  (Feedback)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  RESPONSE       â”‚
                    â”‚  GENERATOR      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Flujos de InteracciÃ³n Detallados
Flujo 1: Consulta Simple (Single-Domain)
Escenario: Usuario de aseguradora pregunta "Â¿QuÃ© cubre mi pÃ³liza de responsabilidad civil?"
Table
Copy
Etapa	Componentes Activos	InteracciÃ³n
1	Domain Router	Clasifica: domain: insurance, confidence: 0.94, subDomain: liability
2	Vector Space Selector	Selecciona Ã­ndice tenant_abc_insurance_vectors
3	Prompt Service	Recupera prompt EXTRACTION_INSURANCE_LIABILITY con contexto de coberturas
4	Entity Engine	Resuelve "pÃ³liza" â†’ entidad genÃ©rica con alias insurance (policy)
5	RAG Orchestrator	Ejecuta retrieval en Ã­ndice especÃ­fico + generaciÃ³n con prompt especializado
6	Compliance Filter	Valida contra reglas Solvency II: Â¿menciona exclusiones obligatorias?
7	Response Generator	Emite respuesta con disclaimer regulatorio automÃ¡tico
Punto de fricciÃ³n: Si el Domain Router tiene confianza baja (0.6), el flujo cambia radicalmente.
Flujo 2: Consulta Ambigua (Cross-Domain Trigger)
Escenario: Usuario pregunta "Â¿EstÃ¡ cubierto el daÃ±o por negligencia mÃ©dica?"
Table
Copy
Etapa	DecisiÃ³n	AcciÃ³n
1	Domain Router	confidence: 0.52, candidateDomains: [insurance, healthcare, legal]
2	Router config	requiresCrossDomain: true (umbral tÃ­pico: 0.75)
3	Vector Space Selector	Activa bÃºsqueda paralela en 3 Ã­ndices
4	Retrieval	Cada Ã­ndice devuelve top-k resultados
5	Merge Strategy	Aplica configuraciÃ³n de tenant: insurance: 0.5, legal: 0.3, healthcare: 0.2
6	Reranking	Modelo cross-domain reordena por relevancia inter-sector
7	Prompt Service	Selecciona prompt COMPARISON_MULTI_DOMAIN
8	Entity Engine	Resuelve "negligencia mÃ©dica" â†’ entidad claim (insurance) + malpractice (legal)
9	Compliance Filter	Aplica reglas mÃ¡s restrictivas de los 3 dominios involucrados
10	Response	Estructurada por dominio: "Desde perspectiva aseguradora... / Legalmente... / ClÃ­nicamente..."
Punto de fricciÃ³n: Latencia multiplicada por 3. Necesario timeout por Ã­ndice + fallback parcial.
Flujo 3: Cambio de Contexto DinÃ¡mico
Escenario: Mismo tenant, usuarios con roles diferentes ven el mismo tÃ©rmino diferente.
Table
Copy
Contexto	Input	ResoluciÃ³n Entity Engine	Output UI
TÃ©cnico de siniestros	"Abrir nuevo claim"	Alias insurance: claim â†’ entidad genÃ©rica	Formulario "Nuevo Siniestro"
Abogado interno	"Abrir caso de claim"	Alias legal: case â†’ misma entidad genÃ©rica	Formulario "Nuevo Caso"
MÃ©dico de la aseguradora	"Episodio relacionado"	Alias healthcare: episode â†’ misma entidad	Formulario "Nuevo Episodio"
Punto de fricciÃ³n: SincronizaciÃ³n de estados. Si el tÃ©cnico cambia estado a "en evaluaciÃ³n", el abogado debe ver "caso en valoraciÃ³n" no "claim pending".
Matriz de Interacciones CrÃ­ticas
InteracciÃ³n Domain Router â†” Vector Space Selector
Table
Copy
Aspecto	DescripciÃ³n	Estrategia
Cache de decisiÃ³n	Queries similares deben reusar clasificaciÃ³n	Cache Redis con TTL 1h por (query_hash, tenantId)
Fallback	Router caÃ­do o lento	Default al dominio principal del tenant + alerta
ActualizaciÃ³n	Nuevo dominio aÃ±adido a tenant	Invalidar cache + reindexar documentos histÃ³ricos
Conflicto	Query clasificada como A pero usuario solo tiene permiso B	Override a B + log de seguridad
InteracciÃ³n Prompt Service â†” Compliance Filter
Table
Copy
Aspecto	DescripciÃ³n	Estrategia
Pre-validaciÃ³n	Prompts ciertos dominios requieren aprobaciÃ³n legal	Flag requiresLegalReview en prompt schema
InyecciÃ³n	Compliance puede modificar system prompt	AÃ±adir secciÃ³n complianceConstraints dinÃ¡mica
Post-validaciÃ³n	Respuesta generada viola reglas	Rechazo + retry con prompt mÃ¡s restrictivo
Evidencia	AuditorÃ­a necesita trazabilidad	Log de quÃ© reglas se aplicaron en cada generaciÃ³n
InteracciÃ³n Entity Engine â†” Cross-Domain Search
Table
Copy
Aspecto	DescripciÃ³n	Estrategia
DesambiguaciÃ³n	"Claim" en query cross-domain	Entity Engine proporciona expansiÃ³n: [claim, case, incident, episode]
Peso semÃ¡ntico	TÃ©rminos de entidades en ranking	Boost en BM25 para tÃ©rminos del alias del dominio activo
Consistencia	Misma entidad referenciada en diferentes dominios	ID Ãºnico interno, aliases por dominio para presentaciÃ³n
MigraciÃ³n	Entidad cambia de dominio (reclasificaciÃ³n)	Evento de dominio + reindexaciÃ³n selectiva
Patrones de Fallo y MitigaciÃ³n
PatrÃ³n 1: OscilaciÃ³n de Dominio
SÃ­ntoma: Query "pÃ³liza de seguro de crÃ©dito" oscila entre insurance y banking en recargas sucesivas.
Causa: TÃ©rminos de alta frecuencia en ambos dominios, embeddings similares.
MitigaciÃ³n:
AÃ±adir historial de conversaciÃ³n al Domain Router (contexto multi-turn)
Configurar domainStickiness: una vez clasificado, mantener 3 turnos o hasta negaciÃ³n explÃ­cita
Umbral de histeresis: cambiar dominio requiere delta de confianza > 0.15
PatrÃ³n 2: ContaminaciÃ³n Cross-Domain
SÃ­ntoma: Respuesta sobre "jurisprudencia en siniestros" mezcla conceptos legales de Common Law con Civil Law incorrectamente.
Causa: Merge de resultados sin comprensiÃ³n de incompatibilidades jurisdiccionales.
MitigaciÃ³n:
AÃ±adir campo jurisdiction a metadatos de chunks
Filtro post-merge: eliminar chunks con jurisdicciÃ³n incompatible con tenant
Prompt especÃ­fico: "Responde solo basado en jurisprudencia [civil/common] law"
PatrÃ³n 3: Entity Drift
SÃ­ntoma: Usuario A (insurance) crea "claim #123", Usuario B (legal) busca "case #123" y no lo encuentra.
Causa: Entity Engine no sincroniza aliases en tiempo real o bÃºsqueda no expande sinÃ³nimos.
MitigaciÃ³n:
Ãndice invertido de aliases: cada entidad indexada bajo todos sus nombres de dominio
SincronizaciÃ³n eventual: evento de creaciÃ³n propaga aliases a servicio de bÃºsqueda
Query expansion automÃ¡tica: bÃºsqueda de "case" expande a ["case", "claim", "incident", "episode"] con pesos por dominio del usuario
ConfiguraciÃ³n de Tenant como Punto de CoordinaciÃ³n
La configuraciÃ³n de cada tenant debe actuar como orquestador estÃ¡tico que reduce complejidad en runtime:
yaml
Copy
# Ejemplo conceptual de configuraciÃ³n tenant

tenant_id: "consultora_xyz"
enabled_domains: ["legal", "insurance", "banking"]
primary_domain: "legal"  # Fallback si router duda

domain_weights:
  legal: 0.5
  insurance: 0.3
  banking: 0.2

cross_domain:
  enabled: true
  threshold: 0.75  # Confianza mÃ­nima para no activar cross-domain
  max_domains: 2   # Limitar bÃºsqueda paralela
  merge_strategy: "weighted"

entity_aliases:
  legal: "case"
  insurance: "claim"
  banking: "incident"

compliance_profile: "strict"  # Aplica reglas mÃ¡s restrictivas de todos los dominios habilitados
Esta configuraciÃ³n es leÃ­da por:
Domain Router (para threshold y max_domains)
Vector Space Selector (para domain_weights)
Entity Engine (para entity_aliases)
Compliance Filter (para compliance_profile)
MÃ©tricas de Salud del Sistema de Interacciones
Table
Copy
MÃ©trica	DefiniciÃ³n	Alerta
Router Consistency	% de queries que mantienen clasificaciÃ³n en reejecuciÃ³n	< 95%
Cross-Domain Rate	% de queries que activan bÃºsqueda multi-dominio	> 30% (posible ambigÃ¼edad sistemÃ¡tica)
Entity Resolution Time	Tiempo desde query hasta entidad resuelta	> 200ms
Compliance Rejection Rate	% de respuestas rechazadas post-generaciÃ³n	> 5% (prompts mal calibrados)
Domain Confidence Distribution	DesviaciÃ³n estÃ¡ndar de confianzas por dominio	Alta = dominios mal definidos
DecisiÃ³n ArquitectÃ³nica Pendiente
OpciÃ³n A: Pipeline Secuencial (recomendada para MVP)
Router â†’ Selector â†’ Retrieval â†’ Prompt â†’ Generation â†’ Compliance
Predecible, debuggable, latencia acumulativa conocida
OpciÃ³n B: Graph Execution (futuro)
Copy
Router activa nodos en paralelo
Selector y Prompt Service se ejecutan simultÃ¡neamente
Compliance como guarda final
Menor latencia, mayor throughput, complejidad de orquestaciÃ³n
RecomendaciÃ³n: Implementar A con hooks claros para evolucionar a B. Cada componente debe exponer interfaz async que permita paralelizaciÃ³n futura sin cambio de contrato.
Â¿Necesitas que profundice en algÃºn flujo especÃ­fico, en la estrategia de migraciÃ³n desde tu arquitectura actual, o en el diseÃ±o de la configuraciÃ³n de tenant?
dÃ­me la estratÃ©gia de migraciÃ³n
Edit
Copy
Share
AquÃ­ tienes la estrategia de migraciÃ³n completa, diseÃ±ada para minimizar riesgo operacional y permitir rollback en cada fase:
Principios Rectores
Table
Copy
Principio	AplicaciÃ³n
Backward Compatibility	Cada fase debe funcionar con datos y APIs existentes
Feature Flags	Todo nuevo comportamiento desactivable por tenant
Shadow Mode	Nuevos componentes ejecutan en paralelo sin afectar respuestas reales
Data Migration Lazy	No reindexar todo de golpe; migrar on-read y on-write
Rollback por Capas	Cada componente puede revertirse independientemente
Fases de MigraciÃ³n
FASE 0: PreparaciÃ³n (Semanas 1-2)
Objetivo: Infraestructura para soportar la migraciÃ³n sin cambios funcionales visibles.
QuÃ© implementar
Sistema de Feature Flags
Nueva colecciÃ³n tenant_feature_flags
Flags iniciales: domain_router_enabled, domain_prompts_enabled, vector_spaces_segregated
Todas en false por defecto para todos los tenants
Logging de Baseline
Extender logs actuales para capturar: dominio detectado (manual por ahora), confianza del clasificador (placeholder), tiempo de retrieval por colecciÃ³n
Establecer mÃ©tricas actuales como referencia
Estructuras de Datos Duales
AÃ±adir campos opcionales a esquemas existentes: domain (string), vector_space_id (string, default null)
Ãndices nuevos creados pero no utilizados aÃºn
ValidaciÃ³n de salida
[ ] Feature flags funcionan en todos los entornos
[ ] MÃ©tricas baseline visibles en dashboard
[ ] Rollback: eliminar flags, sin impacto
FASE 1: Domain Router en Shadow Mode (Semanas 3-4)
Objetivo: Entrenar y validar el clasificador sin afectar usuarios.
QuÃ© implementar
Domain Router Service
ImplementaciÃ³n completa del servicio
Dos modos: LLM-based y embedding-based (configurable por tenant)
Cache de clasificaciones activo
Shadow Execution
En cada query RAG, ejecutar Domain Router en paralelo
Loguear: clasificaciÃ³n propuesta, confianza, tiempo de ejecuciÃ³n
Respuesta al usuario usa flujo legacy (ignora clasificaciÃ³n)
ValidaciÃ³n de Calidad
Dashboard comparativo: clasificaciÃ³n manual vs automÃ¡tica
Umbral de aceptaciÃ³n: 95% concordancia en top-1 domain para queries claras
Gradual Rollout
Table
Copy
Semana	Alcance	Criterio de avance
3a	1 tenant de staging	Sin errores de ejecuciÃ³n
3b	Todos tenants staging	Concordancia > 90%
4a	1 tenant producciÃ³n (voluntario)	Concordancia > 95%
4b	5 tenants producciÃ³n	Sin degradaciÃ³n de mÃ©tricas
Rollback
Desactivar flag domain_router_shadow â†’ Router deja de ejecutar
Sin cambios en datos ni APIs
FASE 2: Router Activo con Fallback (Semanas 5-6)
Objetivo: Router determina flujo, pero fallback a legacy disponible.
QuÃ© implementar
Router como Orquestador
Query entra â†’ Router clasifica â†’ SelecciÃ³n de Ã­ndice basada en clasificaciÃ³n
Si confianza < umbral, fallback a Ã­ndice unificado legacy
Header de respuesta indica: X-Domain-Used: insurance|legacy
Dual Write Inicial
Nuevos documentos: escribir a Ã­ndice legacy + Ã­ndice especÃ­fico de dominio (si detectado)
Lectura: preferir Ã­ndice especÃ­fico, fallback a legacy
Monitoreo Intensivo
Alerta si tasa de fallback > 10%
Alerta si latencia p95 > baseline + 50ms
Gradual Rollout
Table
Copy
Segmento	Criterio de inclusiÃ³n
Early adopters	Tenants single-domain con alta volumetrÃ­a
MayorÃ­a	Tenants single-domain estÃ¡ndar
Excluidos	Tenants multi-domain complejos (fase 5)
Rollback
Activar flag domain_router_force_legacy para tenant especÃ­fico
Respuestas vuelven a flujo unificado inmediatamente
FASE 3: Prompts con DimensiÃ³n de Dominio (Semanas 7-8)
Objetivo: Prompts especializados por vertical.
QuÃ© implementar
Schema Extendido
Prompts existentes: campo domain = generic (default)
Nuevos prompts: domain especÃ­fico, subDomain opcional
LÃ³gica de SelecciÃ³n
Router determina dominio â†’ Prompt Service busca prompt mÃ¡s especÃ­fico disponible
JerarquÃ­a: EXTRACTION_INSURANCE_LIABILITY > EXTRACTION_INSURANCE > EXTRACTION_GENERIC
Si no hay prompt especÃ­fico, usar genÃ©rico (backward compatibility)
MigraciÃ³n de Prompts Existentes
AnÃ¡lisis: quÃ© prompts son realmente genÃ©ricos vs de dominio implÃ­cito
CreaciÃ³n de variantes por dominio para los 20% mÃ¡s usados
ValidaciÃ³n
A/B test: 50% usuarios ven prompts de dominio, 50% genÃ©ricos
MÃ©trica: relevance score en evaluaciones RAG
Avance si mejora > 10% o neutral, rollback si degradaciÃ³n > 5%
Rollback
Flag domain_prompts_enabled = false â†’ todos los prompts se tratan como genÃ©ricos
Sin pÃ©rdida de datos
FASE 4: Entity Engine con Domain Aliases (Semanas 9-10)
Objetivo: Misma entidad, diferentes nombres por dominio.
QuÃ© implementar
Definiciones de Entidad Extendidas
AÃ±adir domainAliases a entidades core (pedido, cliente, documento)
Mantener API actual: getEntity('pedido') funciona igual
Nueva API opcional: getEntity('pedido', { domain: 'insurance' })
ResoluciÃ³n de Alias
UI pide "nuevo claim" â†’ Entity Engine resuelve a entidad genÃ©rica con presentaciÃ³n "claim"
API interna usa ID Ãºnico estable
MigraciÃ³n de Datos HistÃ³ricos
Script batch: poblar domainAliases basado en industry del tenant
EjecuciÃ³n por tenant, fuera de horario pico
ValidaciÃ³n
Tests de integraciÃ³n: mismo flujo ejecutado con diferentes aliases produce mismo resultado interno
Usuarios de diferentes dominios ven terminologÃ­a correcta
Rollback
Ignorar campo domainAliases, usar name base siempre
UI muestra nombre genÃ©rico temporalmente
FASE 5: Vector Spaces Segregados (Semanas 11-14)
Objetivo: Ãndices separados por dominio, migraciÃ³n completa de datos.
QuÃ© implementar
Estructura de Ãndices
Copy
Antes: tenant_abc_vectors (Ãºnico)
DespuÃ©s: 
  - tenant_abc_generic_vectors (legacy, read-only)
  - tenant_abc_insurance_vectors
  - tenant_abc_legal_vectors
  - ...
MigraciÃ³n Lazy de Documentos
On-write: indexar en espacio especÃ­fico de dominio
On-read: si documento no estÃ¡ en Ã­ndice especÃ­fico, copiar desde legacy y reindexar
Background job: migraciÃ³n progresiva de documentos frecuentemente accedidos
Selector de Espacio
Basado en clasificaciÃ³n del Router
ConfiguraciÃ³n de tenant: vector_spaces_enabled_domains
Gradual Rollout CrÃ­tica
Table
Copy
Fase	DescripciÃ³n	ValidaciÃ³n
5.1	Nuevos documentos a Ã­ndices especÃ­ficos	VerificaciÃ³n de indexaciÃ³n correcta
5.2	Queries single-domain a Ã­ndices especÃ­ficos	ComparaciÃ³n de recall vs baseline
5.3	Background migration de documentos histÃ³ricos	Progreso > 80%
5.4	Desactivar escritura en Ã­ndice legacy	Solo lectura fallback
5.5	EliminaciÃ³n Ã­ndice legacy (meses despuÃ©s)	Confirmar 0 accesos
Rollback
Revertir a Ã­ndice unificado: activar flag force_legacy_vector_space
Documentos nuevos duplicados en legacy durante perÃ­odo de transiciÃ³n
FASE 6: Compliance por Dominio (Semanas 15-16)
Objetivo: Regulaciones especÃ­ficas por vertical.
QuÃ© implementar
Motor de Reglas
ConfiguraciÃ³n por dominio: retenciÃ³n, prohibiciones, requisitos de audit
IntegraciÃ³n con Guardian: polÃ­ticas ABAC con atributos de dominio
ValidaciÃ³n de Respuestas
Post-procesamiento: verificar que respuesta no viole reglas del dominio detectado
Si violaciÃ³n: rechazo + retry con constraints adicionales
ValidaciÃ³n
AuditorÃ­a de seguridad por dominio
Penetration testing: intentar obtener respuestas prohibidas
FASE 7: Cross-Domain Search (Semanas 17-20)
Objetivo: BÃºsqueda inteligente multi-dominio para consultas ambiguas.
QuÃ© implementar
ActivaciÃ³n Condicional
Solo cuando Router indica requiresCrossDomain: true
ConfiguraciÃ³n de tenant: dominios permitidos para cross-search
Merge de Resultados
Estrategias: weighted (por config), union, intersection
Reranking especÃ­fico para resultados multi-dominio
ValidaciÃ³n
Dataset de queries ambiguas etiquetadas manualmente
MÃ©trica: precision@5 en resultados cross-domain vs single-domain forzado
Estrategia de Datos Durante MigraciÃ³n
Estado de Documentos por Fase
Table
Copy
Fase	Ãndice Legacy	Ãndices EspecÃ­ficos	Estado
0-2	Read/Write	No existen	Ãšnico
3-4	Read/Write	Write (nuevos)	Dual write
5	Read/Write	Read/Write (lazy migrate)	TransiciÃ³n
6	Read-only	Read/Write	Casi final
7+	Eliminado	Read/Write	Final
SincronizaciÃ³n de Entidades
Copy
Cambio de estado en entidad
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Evento de      â”‚â”€â”€â”€â”€â”
â”‚  Dominio        â”‚    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
        â”‚              â”‚
        â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Projection     â”‚  â”‚  Projection     â”‚
â”‚  Insurance      â”‚  â”‚  Legal          â”‚
â”‚  (claim status) â”‚  â”‚  (case status)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Consistency    â”‚
        â”‚  Check (eventual)â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Plan de Rollback Global
Table
Copy
Escenario	AcciÃ³n	Tiempo de RecuperaciÃ³n
DegradaciÃ³n de calidad RAG	Desactivar Domain Router para tenant afectado	< 1 minuto (flag)
Latencia excesiva	Forzar modo embedding-based (vs LLM) en Router	< 5 minutos
Inconsistencia de datos	Pausar background jobs, reindexar desde backup	2-4 horas
Fallo de Ã­ndices especÃ­ficos	Fallback a Ã­ndice legacy para todos los tenants	< 1 minuto
Error crÃ­tico de compliance	Modo "solo lectura" en RAG para dominio afectado	Inmediato
Checklist de Go/No-Go por Fase
Antes de activar Fase N en producciÃ³n:
[ ] MÃ©tricas de Fase N-1 estables por 1 semana
[ ] Runbook de rollback escrito y probado en staging
[ ] Dashboard de monitoreo especÃ­fico de Fase N operativo
[ ] Equipo de soporte entrenado en sÃ­ntomas de fallo
[ ] ComunicaciÃ³n a clientes (si aplica) enviada
[ ] Backup de datos completo validado
EstimaciÃ³n de Recursos
Table
Copy
Fase	Esfuerzo Dev	Esfuerzo QA	Riesgo	Clientes Afectados
0	1 dev-week	0.5 week	Bajo	Ninguno
1	2 dev-weeks	1 week	Medio	Staging only
2	2 dev-weeks	2 weeks	Alto	Early adopters
3	2 dev-weeks	1 week	Medio	Gradual
4	2 dev-weeks	1 week	Medio	Gradual
5	4 dev-weeks	3 weeks	Muy Alto	Todos (progresivo)
6	2 dev-weeks	2 weeks	Alto	Por dominio
7	3 dev-weeks	2 weeks	Medio	Opt-in
Total estimado: 20 semanas de desarrollo + 12 semanas de QA paralela, con solapamiento entre fases estables.
Â¿Necesitas detalle en alguna fase especÃ­fica, en la estrategia de comunicaciÃ³n con clientes, o en el diseÃ±o del sistema de feature flags?
diseÃ±o de features flag
Edit
Copy
Share
AquÃ­ tienes el diseÃ±o completo del sistema de Feature Flags, pensado especÃ­ficamente para la complejidad de tu migraciÃ³n multi-vertical:
Arquitectura General del Sistema
Niveles de ConfiguraciÃ³n (JerarquÃ­a de Precedencia)
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NIVEL 5: REQUEST (Header/Cookie)       â”‚ â† Mayor precedencia
â”‚  x-feature-override: domain_router=off  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NIVEL 4: USER (SesiÃ³n/Token)           â”‚
â”‚  user.featureOverrides[]                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NIVEL 3: TENANT (OrganizaciÃ³n)         â”‚
â”‚  tenant.config.featureFlags             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NIVEL 2: DOMAIN (Vertical)             â”‚
â”‚  domainConfig.featureDefaults           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NIVEL 1: GLOBAL (Plataforma)           â”‚ â† Menor precedencia
â”‚  platform.defaults.featureFlags         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Regla de resoluciÃ³n: Nivel mÃ¡s especÃ­fico gana. Permite overrides graduales sin conflictos.
Schema de Feature Flags
Estructura Base
Copy
feature_flag
â”œâ”€â”€ id: string (Ãºnico global)
â”œâ”€â”€ scope: "global" | "domain" | "tenant" | "user"
â”œâ”€â”€ target: string (domain_id, tenant_id, user_id, o "*")
â”œâ”€â”€ state: "off" | "shadow" | "gradual" | "on"
â”œâ”€â”€ conditions: Condition[]
â”œâ”€â”€ metadata
â”‚   â”œâ”€â”€ description
â”‚   â”œâ”€â”€ owner (equipo responsable)
â”‚   â”œâ”€â”€ createdAt, expiresAt
â”‚   â””â”€â”€ rollbackWindow (horas para revertir)
â””â”€â”€ audit
    â”œâ”€â”€ lastModifiedBy
    â”œâ”€â”€ lastModifiedAt
    â””â”€â”€ changeHistory[]
Estados de Feature
Table
Copy
Estado	Comportamiento	Uso en tu migraciÃ³n
off	CÃ³digo ni se ejecuta	Fases aÃºn no iniciadas
shadow	Ejecuta en paralelo, no afecta respuesta	Fase 1: Domain Router
gradual	Activo para % de trÃ¡fico o segmentos	Fase 2-5: Rollout progresivo
on	Activo para todos	Fase estable
deprecated	Activo pero marcado para eliminaciÃ³n	Post-migraciÃ³n, limpieza
Condiciones Avanzadas
Permiten activaciÃ³n contextual sin cÃ³digo adicional:
yaml
Copy
conditions:
  - type: "timeRange"           # Horario de baja carga
    start: "02:00"
    end: "06:00"
    timezone: "Europe/Madrid"
    
  - type: "trafficPercentage"   # Gradual rollout
    value: 10                   # 10% de requests
    
  - type: "tenantSegment"       # Segmentos de riesgo
    include: ["beta_testers"]
    exclude: ["enterprise_tier1"]
    
  - type: "queryComplexity"     # Solo queries simples
    metric: "token_count"
    max: 500
    
  - type: "domainConfidence"    # Solo si Router confÃ­a
    min: 0.85
    
  - type: "canary"              # 1 tenant especÃ­fico
    tenantId: "test_abc"
    duration: "24h"
Sistema de EvaluaciÃ³n (Feature Engine)
Flujo de EvaluaciÃ³n por Request
Copy
Request entra
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Resolver       â”‚ â† Determinar todos los flags aplicables
â”‚  Contexto       â”‚   (user, tenant, domain, request params)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Evaluar        â”‚ â† Para cada flag relevante:
â”‚  Condiciones    â”‚   - Â¿Aplica timeRange?
â”‚                 â”‚   - Â¿Pasa trafficPercentage?
â”‚                 â”‚   - Â¿Cumple queryComplexity?
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Resolver       â”‚ â† Determinar estado final
â”‚  Precedencias   â”‚   (user override > tenant > domain > global)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Cachear        â”‚ â† TTL corto (5-30s) para no reevaluar
â”‚  Resultado      â”‚   mismo request
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
  Estado final: { flag1: "on", flag2: "shadow", ... }
Performance
Table
Copy
Aspecto	Estrategia	Target
Latencia de evaluaciÃ³n	Cache local + Redis	< 5ms p99
Consistencia	Eventual: propagaciÃ³n < 2s	Stale reads aceptables
Disponibilidad	Fallback a defaults si Redis cae	100% uptime degradado
Feature Flags EspecÃ­ficos de la MigraciÃ³n
Fase 1: Domain Router
Table
Copy
Flag	Estados	DescripciÃ³n
domain_router.enabled	off â†’ shadow â†’ gradual â†’ on	Master switch del router
domain_router.mode	"embedding" / "llm" / "hybrid"	Estrategia de clasificaciÃ³n
domain_router.cache_ttl	nÃºmero (segundos)	DuraciÃ³n de cache por query
domain_router.fallback_threshold	0.0 - 1.0	Confianza mÃ­nima para no fallback
domain_router.shadow.log_only	true / false	En shadow, Â¿loggear detalle?
Fase 2: Router Activo
Table
Copy
Flag	Estados	DescripciÃ³n
domain_router.force_legacy	true / false	Bypass a flujo unificado
domain_router.domain_whitelist	["insurance", "legal"]	Dominios permitidos para este tenant
domain_router.cross_domain.enabled	false â†’ true	Permitir bÃºsqueda multi-dominio
Fase 3: Prompts por Dominio
Table
Copy
Flag	Estados	DescripciÃ³n
prompts.domain_aware.enabled	off â†’ on	SelecciÃ³n de prompts por dominio
prompts.domain_aware.fallback_generic	true / false	Si no hay prompt especÃ­fico, Â¿usar genÃ©rico?
prompts.domain_aware.strict_mode	true / false	Error si no hay prompt para dominio detectado
Fase 4: Entity Engine
Table
Copy
Flag	Estados	DescripciÃ³n
entities.domain_aliases.enabled	off â†’ on	ResoluciÃ³n de aliases por dominio
entities.domain_aliases.ui_transform	true / false	Transformar nombres en UI
entities.domain_aliases.api_transform	true / false	Aceptar aliases en API inputs
Fase 5: Vector Spaces
Table
Copy
Flag	Estados	DescripciÃ³n
vectors.segregation.enabled	off â†’ gradual â†’ on	Usar Ã­ndices separados por dominio
vectors.segregation.dual_write	true / false	Escribir a legacy + especÃ­fico
vectors.segregation.lazy_migration	true / false	Migrar documentos on-read
vectors.segregation.force_legacy_read	true / false	Ignorar Ã­ndices especÃ­ficos
vectors.segregation.background_job	"paused" / "active" / "completed"	Estado de migraciÃ³n batch
Fase 6: Compliance
Table
Copy
Flag	Estados	DescripciÃ³n
compliance.domain_rules.enabled	off â†’ on	Aplicar reglas por dominio
compliance.domain_rules.enforce	"log" / "warn" / "block"	Nivel de enforce
compliance.domain_rules.audit_all	true / false	Loggear todas las validaciones
UI de AdministraciÃ³n
Vista por Tenant
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tenant: Consultora ABC          [+] AÃ±adir Override    â”‚
â”‚  Dominios: [legal] [insurance] [banking]                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FEATURE                          ESTADO      ACCIONES  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  domain_router.enabled            GRADUAL 10%  [â–²] [â–¼] [âœ] â”‚
â”‚    â””â”€ Modo: embedding                                   â”‚
â”‚    â””â”€ Fallback: 0.75                                    â”‚
â”‚  prompts.domain_aware.enabled     ON         [âœ] [ğŸ—‘]   â”‚
â”‚  vectors.segregation.enabled      SHADOW     [â–²] [âœ]    â”‚
â”‚    â””â”€ Dual write: âœ“                                     â”‚
â”‚    â””â”€ Lazy migration: âœ“                                 â”‚
â”‚  entities.domain_aliases.enabled  OFF        [â–²]        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [ğŸ’¾ Guardar]  [ğŸ”„ Reset a defaults de dominio]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Vista Global (SuperAdmin)
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PLATFORM FEATURE FLAGS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Feature                    Default    Tenants Override â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  domain_router.enabled      SHADOW     45 ON / 12 OFF   â”‚
â”‚  vectors.segregation        OFF        3 GRADUAL        â”‚
â”‚  ...                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [ğŸ“Š Ver mÃ©tricas de uso]  [ğŸš¨ Alertas configuradas]    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
IntegraciÃ³n con CÃ³digo
PatrÃ³n de Uso (TypeScript)
TypeScript
Copy
// InicializaciÃ³n (una vez por request)
const features = await featureEngine.evaluate({
  request: req,
  user: session.user,
  tenant: session.user.tenantId,
  domain: detectedDomain // si ya se conoce
});

// Uso en lÃ³gica de negocio
if (features.isOn('domain_router.enabled')) {
  const classification = await domainRouter.classify(query);
  
  if (features.isInShadow('domain_router.enabled')) {
    // Loguear pero no usar
    analytics.logShadow('domain_router', classification);
  } else {
    // Usar para decisiÃ³n real
    vectorSpace = classification.domain;
  }
}

// Con condiciones inline
if (features.evaluate('vectors.segregation.enabled', {
  onlyIf: { trafficPercentage: 10 }
})) {
  // Solo entra para 10% del trÃ¡fico
}

// Fallback explÃ­cito
const indexName = features.get('vectors.index_name', {
  fallback: 'tenant_legacy_vectors'
});
Decoradores (para endpoints)
TypeScript
Copy
@FeatureGate('domain_router.enabled', { 
  mode: 'shadow',
  track: 'domain_router_metrics'
})
async function searchEndpoint(req: Request) {
  // El decorador maneja logging y mÃ©tricas automÃ¡ticamente
}

@FeatureGate('compliance.domain_rules.enabled', {
  mode: 'block', // Rechaza request si feature off
  errorMessage: 'Compliance validation unavailable'
})
async function validateResponse(data: any) {
  // Solo ejecuta si feature activa
}
Eventos y Observabilidad
Eventos Emitidos
Table
Copy
Evento	CuÃ¡ndo	Datos
feature.evaluated	Cada evaluaciÃ³n	flag, context, result, latency
feature.state_changed	Cambio de estado	flag, oldState, newState, actor
feature.shadow_mismatch	Shadow detecta diferencia	flag, expected, actual, severity
feature.gradual_advanced	Aumento de %	flag, old%, new%, criteria
feature.emergency_rollback	Rollback automÃ¡tico	flag, trigger, timestamp
MÃ©tricas Clave
Copy
feature_flag_evaluations_total{flag, state, result}
feature_flag_evaluation_duration_seconds{flag, percentile}
feature_flag_state_changes_total{flag, transition}
feature_flag_shadow_mismatches_total{flag, severity}
feature_flag_active_tenants{flag, state}
Estrategias de Rollback AutomÃ¡tico
Triggers de Auto-Rollback
Table
Copy
CondiciÃ³n	AcciÃ³n	NotificaciÃ³n
Error rate > baseline + 5%	Degradar a shadow	Slack #alerts
Latencia p99 > 2x baseline	Forzar modo ligero	PagerDuty
Shadow mismatch > 10%	Pausar gradual	Email owner
3+ errores 500 en 1 minuto	Off inmediato	Todo
Ventana de Rollback
Cada feature tiene configurado:
yaml
Copy
rollbackWindow:
  automatic: true        # Â¿Permitir auto-rollback?
  maxDuration: "4h"      # DespuÃ©s de esto, rollback manual solo
  requireApproval: false # Â¿Necesita ticked de aprobaciÃ³n?
  approvers: ["team-lead", "sre-oncall"]
SincronizaciÃ³n Multi-Entorno
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Push manual     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Production â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Staging   â”‚
â”‚   (cauteloso)â”‚   con validaciÃ³n   â”‚  (pruebas)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–²                                    â”‚
       â”‚         Sync automÃ¡tico            â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              (solo defaults, no overrides)
Reglas:
Defaults globales: sync automÃ¡tico staging â†’ prod con validaciÃ³n
Overrides de tenant: nunca sync automÃ¡tico, migraciÃ³n manual con checklist
Emergencias: posible push directo a prod con aprobaciÃ³n de 2 personas
Checklist de ImplementaciÃ³n
Semana 1: Infraestructura Base
[ ] Schema de MongoDB para feature flags
[ ] Servicio Redis para cache
[ ] API REST para CRUD de flags
[ ] Middleware de Express/Next.js para evaluaciÃ³n
Semana 2: UI y Observabilidad
[ ] Dashboard de administraciÃ³n
[ ] IntegraciÃ³n con sistema de logs existente
[ ] Alertas configuradas
[ ] DocumentaciÃ³n de runbooks
Semana 3: IntegraciÃ³n con MigraciÃ³n
[ ] Flags de Fase 0 y 1 definidos
[ ] Tests de shadow mode
[ ] ValidaciÃ³n de performance
Â¿Necesitas profundizar en algÃºn aspecto: el algoritmo de gradual rollout, la estrategia de cache, los mecanismos de seguridad para prevenir activaciÃ³n accidental, o la integraciÃ³n especÃ­fica con tu stack Next.js/MongoDB?
ves diciendome todo
Edit
Copy
Share
Voy a profundizar en todos los aspectos que mencionÃ©, uno por uno. Empezamos con el algoritmo de gradual rollout:
Algoritmo de Gradual Rollout
Problema a Resolver
Necesitas activar una feature para un porcentaje creciente de trÃ¡fico, pero de forma determinista (mismo usuario siempre ve mismo estado) y controlable (puedes segmentar por riesgo).
Estrategias de AsignaciÃ³n
Table
Copy
Estrategia	DescripciÃ³n	CuÃ¡ndo Usar	Ejemplo en tu caso
Random	Aleatorio puro por request	Testing de carga, no importa consistencia	Stress test de Domain Router
Sticky (User ID)	Hash de user_id % 100	Consistencia por usuario, mÃºltiples sesiones	Prompts por dominio (mismo usuario, misma experiencia)
Sticky (Tenant)	Hash de tenant_id % 100	Consistencia por organizaciÃ³n	Vector spaces (migraciÃ³n por tenant completo)
Sticky (Entity)	Hash de entity_id % 100	Consistencia por objeto	Lazy migration de documentos
Segment-based	Grupos predefinidos (beta, enterprise, etc.)	Control manual, alta confianza	Early adopters de Fase 2
Time-based	Ventanas horarias	Reducir riesgo en horario pico	Fase 5 background migration
Algoritmo Sticky Hash (Recomendado para tu caso)
Copy
Entrada: user_id (o tenant_id), feature_key, percentage (0-100)

1. Concatenar: input = user_id + ":" + feature_key
2. Calcular hash: hash = sha256(input)
3. Tomar Ãºltimos 4 dÃ­gitos hex: suffix = hash[-4:]
4. Convertir a entero: value = hex_to_int(suffix)  // 0-65535
5. Calcular porcentaje: user_percent = (value / 65535) * 100
6. Retornar: user_percent <= percentage
Ventajas:
Mismo usuario siempre mismo resultado para misma feature
Diferentes features tienen distribuciones independientes (no siempre "sÃ­" o "no" juntas)
FÃ¡cil de reproducir para debugging
ProgresiÃ³n TÃ­pica en tu MigraciÃ³n
Table
Copy
DÃ­a	Porcentaje	Criterio para avanzar
1	1%	Monitoreo bÃ¡sico, sin alertas
3	5%	Error rate < baseline + 0.1%
5	10%	Latencia p95 < baseline + 10%
7	25%	Sin tickets de soporte relacionados
10	50%	MÃ©tricas de negocio estables
14	100%	3 dÃ­as sin incidentes
Segmentos Prioritarios (para tu caso multi-vertical)
Copy
Orden de inclusiÃ³n en gradual rollout:

1. Tenants "beta" voluntarios (bajo riesgo, alto feedback)
2. Tenants single-domain simples (ej: solo elevators)
3. Tenants single-domain complejos (ej: solo legal con muchos usuarios)
4. Tenants multi-domain con dominio primario claro (80% legal, 20% insurance)
5. Tenants multi-domain balanceados (50/50) â† Mayor riesgo, al final
6. Enterprise tier 1 (alto riesgo reputacional, requieren aprobaciÃ³n explÃ­cita)
Estrategia de Cache
Niveles de Cache
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1: In-Memory (Node.js)                â”‚
â”‚  - TTL: 5-10 segundos                   â”‚
â”‚  - Capacidad: 1000 entries por proceso  â”‚
â”‚  - Uso: Evaluaciones de feature flags   â”‚
â”‚    para requests concurrentes del       â”‚
â”‚    mismo usuario                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  L2: Redis Cluster                      â”‚
â”‚  - TTL: 30-60 segundos                  â”‚
â”‚  - Capacidad: Ilimitada (escalable)     â”‚
â”‚  - Uso: Compartir estado entre          â”‚
â”‚    instancias de Next.js                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  L3: MongoDB (Source of Truth)          â”‚
â”‚  - Persistencia permanente              â”‚
â”‚  - Uso: ConfiguraciÃ³n, historial,       â”‚
â”‚    auditorÃ­a                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Cache Key Design
Copy
Estructura de clave Redis:

ff:v2:{tenant_id}:{feature_key}:{user_id_hash}

Ejemplo:
ff:v2:consultora_xyz:domain_router.enabled:a3f9b2...

Contenido (JSON):
{
  "state": "gradual",
  "evaluatedAt": "2024-01-15T10:30:00Z",
  "conditions": {
    "trafficPercentage": 25,
    "userInSegment": true
  },
  "finalDecision": true,
  "version": 3  // Para invalidaciÃ³n por cambio de config
}
Estrategia de InvalidaciÃ³n
Table
Copy
Evento	AcciÃ³n	PropagaciÃ³n
Cambio de estado de feature	Invalidar L1 inmediato, L2 con delay 1s	< 2s global
Cambio de condiciones (ej: % de 10â†’25)	Incrementar version en payload, lazy invalidation	Next read detecta versiÃ³n obsoleta
Emergencia (rollback)	Pub/sub a todos los nodos, flush L1 inmediato	< 500ms
ExpiraciÃ³n TTL	Reconstruir desde MongoDB	Transparente
OptimizaciÃ³n para tu Caso Multi-Vertical
Problema: Mismo tenant, diferentes usuarios en diferentes dominios, mismas features.
SoluciÃ³n: Cache por "contexto efectivo":
Copy
Clave de cache = hash(tenant_id + dominio_detectado + feature_key)

Esto permite:
- Usuario A (legal) ve feature ON
- Usuario B (insurance, mismo tenant) ve feature OFF
- Sin re-evaluar condiciones complejas
Mecanismos de Seguridad
PrevenciÃ³n de ActivaciÃ³n Accidental
1. Two-Person Rule (2PR)
Copy
Cambio de estado requiere:

DE: off / shadow / gradual
A:  on / gradual con % > 50

Requiere:
- Aprobador 1: Creador del cambio (developer/PM)
- Aprobador 2: SRE o Team Lead

ImplementaciÃ³n:
- PR en repo de config (GitOps)
- Check automÃ¡tico: Â¿2 aprobaciones de owners diferentes?
- Merge â†’ deploy automÃ¡tico
2. Circuit Breaker por Feature
Copy
Si feature X causa:
- Error rate > 5% en 2 minutos
- Latencia p99 > 3x baseline
- 10+ errores 500 consecutivos

Entonces:
1. Auto-degradar a shadow (si disponible)
2. Si no, auto-off
3. Notificar: Slack #incidents + PagerDuty
4. Bloquear re-activaciÃ³n por 1 hora (cooldown)
3. Dry-Run Mode
Copy
Antes de cualquier cambio en producciÃ³n:

$ featurectl dry-run \
  --feature domain_router.enabled \
  --tenant consultora_xyz \
  --state gradual \
  --percentage 25

Output:
  Usuarios afectados: 45 de 180 (25%)
  Tenants con riesgo alto: 0
  Tenants multi-domain: 3 (recomendado: excluir)
  EstimaciÃ³n de latencia: +12ms p95
  
  [Confirmar] [Modificar] [Cancelar]
4. Time-Based Restrictions
Copy
Cambios a estado "on" o aumento de % > 50:
- Bloqueado: Viernes despuÃ©s de las 18h
- Bloqueado: Fin de semana
- Bloqueado: DÃ­as de cierre de mercado (configurable por tenant)
- Requerido: Ventana de mantenimiento programada
Permisos Granulares
Table
Copy
Rol	Permisos	Scope
SuperAdmin	Todo	Global
Platform Engineer	Cambiar defaults, ver todo	Global, solo lectura en prod
Tenant Admin	Overrides para su tenant	Su tenant Ãºnicamente
Feature Owner	Cambiar su feature, cualquier tenant	Features asignadas
SRE On-call	Emergency rollback, read-only	Global, solo emergencias
Auditor	Solo lectura, historial	Global
Audit Trail Inmutable
Copy
Cada cambio genera registro en:

feature_audit_log
â”œâ”€â”€ timestamp (precisiÃ³n nanosegundos)
â”œâ”€â”€ actor (user_id, ip, user_agent)
â”œâ”€â”€ action (create, update, delete, emergency_rollback)
â”œâ”€â”€ feature_id
â”œâ”€â”€ previous_state (snapshot completo)
â”œâ”€â”€ new_state (snapshot completo)
â”œâ”€â”€ reason (obligatorio para cambios manuales)
â”œâ”€â”€ ticket_reference (Jira/GitHub issue)
â””â”€â”€ signature (HMAC para integridad)

RetenciÃ³n: 7 aÃ±os (compliance)
Almacenamiento: Write-once read-many (WORM) en S3/GCS
IntegraciÃ³n con tu Stack (Next.js + MongoDB)
Arquitectura de Componentes
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Next.js App Router            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Middleware (middleware.ts)     â”‚    â”‚
â”‚  â”‚  - Evaluar flags globales       â”‚    â”‚
â”‚  â”‚  - Inyectar contexto en headers â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                   â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Server Components / API Routes â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚  â”‚  FeatureProvider        â”‚    â”‚    â”‚
â”‚  â”‚  â”‚  (React Context)        â”‚    â”‚    â”‚
â”‚  â”‚  â”‚  - Cache por request    â”‚    â”‚    â”‚
â”‚  â”‚  â”‚  - Re-evaluar si cambia â”‚    â”‚    â”‚
â”‚  â”‚  â”‚    dominio              â”‚    â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â”‚              â”‚                  â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚
â”‚  â”‚  â”‚  Hooks de Feature     â”‚      â”‚    â”‚
â”‚  â”‚  â”‚  useFeature()         â”‚      â”‚    â”‚
â”‚  â”‚  â”‚  useFeatureValue()    â”‚      â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Feature Service (Singleton)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  L1     â”‚ â”‚   L2    â”‚ â”‚    L3    â”‚  â”‚
â”‚  â”‚  Memory â”‚ â”‚  Redis  â”‚ â”‚ MongoDB  â”‚  â”‚
â”‚  â”‚  Cache  â”‚ â”‚  Cache  â”‚ â”‚  Source  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ImplementaciÃ³n EspecÃ­fica por Capa
Middleware (Edge Runtime)
TypeScript
Copy
// Limitaciones: No MongoDB, solo fetch
// Ideal para: Flags globales, geolocalizaciÃ³n, rate limiting

export async function middleware(request: NextRequest) {
  // Solo evaluar flags que afectan routing
  const edgeFlags = await evaluateEdgeFlags({
    geo: request.geo,
    userAgent: request.headers.get('user-agent'),
    // Fetch desde Edge Config de Vercel o similar
  });
  
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-edge-flags', JSON.stringify(edgeFlags));
  
  return NextResponse.next({
    request: { headers: requestHeaders }
  });
}
Server Components (Node.js Runtime)
TypeScript
Copy
// Acceso completo a MongoDB, evaluaciÃ³n rica

async function FeatureServerProvider({ children, tenantId, userId }) {
  const features = await featureService.evaluate({
    tenantId,
    userId,
    // Puede hacer joins complejos con MongoDB
    context: await buildContext(tenantId)
  });
  
  return (
    <FeatureContext.Provider value={features}>
      {children}
    </FeatureContext.Provider>
  );
}
Client Components (Browser)
TypeScript
Copy
// Solo flags seguras para exponer (no lÃ³gica interna)

'use client';

function DomainRouterToggle() {
  // Hook que lee del contexto server-inyectado
  const { isEnabled, toggle } = useClientFeature('domain_router.ui_preview');
  
  // Solo UI, la lÃ³gica real estÃ¡ en server
  return (
    <Switch 
      checked={isEnabled}
      onChange={() => toggle({ reason: 'user_request' })}
    />
  );
}